1
00:00:00,551 --> 00:00:03,134

2
00:00:05,050 --> 00:00:06,150


3
00:00:08,070 --> 00:00:12,727
大家好，欢迎
来到斯坦福大学的CS193p

4
00:00:12,727 --> 00:00:15,820
这是一门关于使用名为SwiftUI的开发环境为


5
00:00:15,820 --> 00:00:19,490
iPhone和iPad等iOS设备开发应用程序的课程。

6
00:00:19,490 --> 00:00:22,043


7
00:00:23,120 --> 00:00:25,230
这是重播。这门

8
00:00:25,230 --> 00:00:26,790
课程最初是

9
00:00:26,790 --> 00:00:30,153
在 2021 年春季季度为我在斯坦福大学的学生开设的。


10
00:00:31,200 --> 00:00:33,090
我的名字是Paul Hegarty。

11
00:00:33,090 --> 00:00:35,930
我已经在斯坦福大学以
一种或另一种形式教授这门课程

12
00:00:35,930 --> 00:00:38,430
大约10年了。

13
00:00:38,430 --> 00:00:41,180
我知道你们所有人都

14
00:00:41,180 --> 00:00:43,770
带着各种各样的背景、

15
00:00:43,770 --> 00:00:46,370
经验和

16
00:00:46,370 --> 00:00:48,890
对你可能从这样的课程中学到的东西的期望。

17
00:00:48,890 --> 00:00:51,640
所以这次我决定


18
00:00:51,640 --> 00:00:53,240
为非斯坦福大学的学生做这个小介绍，

19
00:00:53,240 --> 00:00:55,900



20
00:00:55,900 --> 00:00:57,793
在你开始学习之前，试着让你了解这门课程会发生什么。

21
00:00:59,510 --> 00:01:01,980
这个季度是另一个大流行季度，

22
00:01:01,980 --> 00:01:05,440
只提供远程服务，所以你要去

23
00:01:05,440 --> 00:01:09,820

像我的学生一样在视频上学习这门课程，

24
00:01:09,820 --> 00:01:12,410
这样做肯定有缺点。

25
00:01:12,410 --> 00:01:16,920
我喜欢现场讲座，不能那样做，

26
00:01:16,920 --> 00:01:19,740
但观看视频也有好处。

27
00:01:19,740 --> 00:01:22,780
例如，你有暂停和倒带。

28
00:01:22,780 --> 00:01:24,580


29
00:01:24,580 --> 00:01:27,464
当您使用


30
00:01:27,464 --> 00:01:30,693

本课程中将要找到的技术含量很高的课程内容时，这是一个很棒的功能。

31
00:01:31,590 --> 00:01:34,480
当然，我的学生也有

32
00:01:34,480 --> 00:01:36,640
高度互动的课堂论坛

33
00:01:36,640 --> 00:01:39,055
和助教，你不会有，

34
00:01:39,055 --> 00:01:43,039
但互联网上有大量非常棒的资源。

35
00:01:43,039 --> 00:01:44,850


36
00:01:44,850 --> 00:01:47,284
有一个非常活跃的SwiftUI社区。

37
00:01:47,284 --> 00:01:49,350
这并不是唯一一个出去学习iOS编程的地方。

38
00:01:49,350 --> 00:01:52,070


39
00:01:52,070 --> 00:01:54,050
因此，如果您还没有

40
00:01:54,050 --> 00:01:57,090

观看这些视频，那么您肯定会想在观看这些视频

41
00:01:57,090 --> 00:01:58,283
时寻找所有这些资源。

42
00:01:59,860 --> 00:02:03,420
现在，这门课程以一种叙事形式进行，

43
00:02:03,420 --> 00:02:05,720
这对学生来说效果很好，

44
00:02:05,720 --> 00:02:09,930
因为他们将它与所有其他课程交织在一起。

45
00:02:09,930 --> 00:02:13,230
所以，我们一起工作，

46
00:02:13,230 --> 00:02:17,170
学生和我构建了几个大小合适的应用程序，

47
00:02:17,170 --> 00:02:21,060
一个纸牌游戏和一个绘图应用程序。

48
00:02:21,060 --> 00:02:22,970
所以我在讲课和演示时讲述了故事的一部分，

49
00:02:22,970 --> 00:02:24,970


50
00:02:24,970 --> 00:02:28,310
他们也通过他们的家庭作业参与了讲故事。

51
00:02:28,310 --> 00:02:30,320


52
00:02:30,320 --> 00:02:32,620
他们的家庭作业总是

53
00:02:32,620 --> 00:02:35,850
以我在课堂上所做的事情为基础。

54
00:02:35,850 --> 00:02:38,350
因此，我们将所有作业记录

55
00:02:38,350 --> 00:02:42,990
和所有演示代码发布
在cs193p.stanford.edu上。

56
00:02:42,990 --> 00:02:45,140
所以一定要去找那些。

57
00:02:45,140 --> 00:02:46,700
它们

58
00:02:46,700 --> 00:02:49,333
对于充分利用本课程是绝对必要的。

59
00:02:49,333 --> 00:02:53,240
本课程不仅是一

60
00:02:53,240 --> 00:02:56,370
门iOS编程的入门课程，

61
00:02:56,370 --> 00:02:57,690
也是一门

62
00:02:57,690 --> 00:03:00,310
关于如何工作的课程。

63
00:03:00,310 --> 00:03:02,280
系统设计

64
00:03:02,280 --> 00:03:04,480
对于我们的 CS 学生来说学习非常重要

65
00:03:04,480 --> 00:03:06,940
，因此，我们尝试

66
00:03:06,940 --> 00:03:10,470
在本课程的讲座中花费一些时间来


67
00:03:10,470 --> 00:03:13,330
谈谈 SwiftUI 是如何
做它正在做的事情的，

68
00:03:13,330 --> 00:03:16,810
而不仅仅是如何
转动旋钮来制作 它走了。

69
00:03:16,810 --> 00:03:19,050
所以你会


70
00:03:19,050 --> 00:03:20,573
在整个讲座中看到那种味道。

71
00:03:21,760 --> 00:03:24,560
关于本课程的先决条件。

72
00:03:24,560 --> 00:03:27,070
对于斯坦福的学生来说，

73
00:03:27,070 --> 00:03:30,020
他们有先决条件参加至少三门

74
00:03:30,020 --> 00:03:32,830
并推荐四门CS入门课程。

75
00:03:32,830 --> 00:03:37,240
所以，他们是相对有经验的程序员。

76
00:03:37,240 --> 00:03:38,590


77
00:03:38,590 --> 00:03:42,030
学生在学习CS193p时都知道的一件事

78
00:03:42,030 --> 00:03:44,290
是面向对象编程。

79
00:03:44,290 --> 00:03:47,188
因此，即使我们在SwiftUI中实际上并没有使用太多的面向对象编程，

80
00:03:47,188 --> 00:03:50,300


81
00:03:50,300 --> 00:03:51,940


82
00:03:51,940 --> 00:03:53,640
你在面向对象编程中学到的概念，

83
00:03:53,640 --> 00:03:58,250
比如数据结构和封装的实例，当你试图理解时，

84
00:03:58,250 --> 00:04:00,010
这些都是非常好的

85
00:04:00,010 --> 00:04:03,860

知识SwiftUI是如何工作的。

86
00:04:03,860 --> 00:04:05,980
此外，SwiftUI要求你学习

87
00:04:05,980 --> 00:04:07,820
一种称为Swift的新语言。

88
00:04:07,820 --> 00:04:10,208
对于我所有的学生，

89
00:04:10,208 --> 00:04:12,840
你知道，


90
00:04:12,840 --> 00:04:15,740
他们在来这里之前已经学了三四次新语言，

91
00:04:15,740 --> 00:04:18,960
所以对他们来说学习一门新语言有点老套了。

92
00:04:18,960 --> 00:04:22,640
因此，如果对你来说Swift将成为你的第二语言，

93
00:04:22,640 --> 00:04:25,689
或者你是第一次编码并且它是你的第一语言，

94
00:04:25,689 --> 00:04:30,200
那么这将为


95
00:04:30,200 --> 00:04:33,467
吸收本课程中的所有材料增加一个重大的额外挑战。

96
00:04:33,467 --> 00:04:36,120
因此，正如您可能从所有这些中得出的那样，

97
00:04:36,120 --> 00:04:40,240
本课程并非针对第一次程序员。

98
00:04:40,240 --> 00:04:43,630
不过，我会说，如果你刚刚开始编码，

99
00:04:43,630 --> 00:04:48,070
或者即使你根本不是编码员，

100
00:04:48,070 --> 00:04:49,720
您可能仍然会发现

101
00:04:49,720 --> 00:04:52,267
本课程的前几周非常有趣，

102
00:04:52,267 --> 00:04:56,040
只是看看它是什么喜欢为iOS开发应用程序，

103
00:04:56,040 --> 00:04:59,039
因为我们直接投入其中。

104
00:04:59,039 --> 00:05:02,080
斯坦福大学的学生还没有学过Swift，

105
00:05:02,080 --> 00:05:03,160


106
00:05:03,160 --> 00:05:05,100
所以我们并不认为他们一开始就知道任何东西。

107
00:05:05,100 --> 00:05:07,060
我们要一步一步来。

108
00:05:07,060 --> 00:05:08,930
我们鼓励学生跟随。

109
00:05:08,930 --> 00:05:11,930
作业真的需要他们跟着做。

110
00:05:11,930 --> 00:05:13,783
因此，


111
00:05:13,783 --> 00:05:15,790
无论你的编程经验水平如何，

112
00:05:15,790 --> 00:05:17,890


113
00:05:17,890 --> 00:05:20,170
至少在最初的几堂课中，您都应该能够真正做同样的事情。

114
00:05:20,170 --> 00:05:21,930
然后你可以决定你想从那里去哪里。

115
00:05:21,930 --> 00:05:24,550


116
00:05:24,550 --> 00:05:26,580
因此，


117
00:05:26,580 --> 00:05:28,540
希望这可以为你提供入门所需的所有信息。

118
00:05:28,540 --> 00:05:30,173
所以，我们走吧。

119
00:05:31,040 --> 00:05:33,400
让我们先看看我们将要构建

120
00:05:33,400 --> 00:05:37,200
什么，我们将在这些iPhone模拟器中进行构建。

121
00:05:37,200 --> 00:05:39,370
您在屏幕上看到的这两件事是在此处

122
00:05:39,370 --> 00:05:42,347
模拟左侧的iPhone11


123
00:05:42,347 --> 00:05:44,950
和右侧的iPhone8。

124
00:05:44,950 --> 00:05:46,720
当我们运行我们的应用程序

125
00:05:46,720 --> 00:05:48,270
以查看它是否在做我们想要的事情时，

126
00:05:48,270 --> 00:05:51,200
当然我们可以将我们的iOS设备、

127
00:05:51,200 --> 00:05:54,650
我们的iPhone或iPad插入我们的Mac并在那里运行它。

128
00:05:54,650 --> 00:05:57,370
但是，很多时候，

129
00:05:57,370 --> 00:06:01,400
能够模拟一个设备并在我们的屏幕上直接看到它会更好。

130
00:06:01,400 --> 00:06:03,100
这就是这些模拟器所允许的。

131
00:06:03,100 --> 00:06:05,730
它们不仅模拟我们

132
00:06:05,730 --> 00:06:09,390
在iPhone上运行的应用程序，还模拟大多数iPhone环境，

133
00:06:09,390 --> 00:06:12,300
例如设置应用程序。

134
00:06:12,300 --> 00:06:14,300
我们可以转到设置应用程序

135
00:06:14,300 --> 00:06:17,560
并设置可能影响我们应用程序运行方式的内容，

136
00:06:17,560 --> 00:06:21,550
或者您访问通讯录、日历等的联系人。

137
00:06:21,550 --> 00:06:23,660


138
00:06:23,660 --> 00:06:25,960
我们的应用程序可能想要与之交互的所有这些东西

139
00:06:25,960 --> 00:06:28,483
也在iPhone上进行了模拟。

140
00:06:29,440 --> 00:06:33,620
这是我们将在本季度构建的应用程序。

141
00:06:33,620 --> 00:06:34,880
它被称为记忆。

142
00:06:34,880 --> 00:06:37,397
它还没有应用程序图标。

143
00:06:37,397 --> 00:06:40,300
希望我们能在本季度实现这一目标。

144
00:06:40,300 --> 00:06:42,350
我只是要点击它来运行它。

145
00:06:43,220 --> 00:06:47,260
在这里，这是一个游戏。

146
00:06:47,260 --> 00:06:50,328
我要点击这里查看它的万圣节版本。 
是一款纸牌配对游戏。

147
00:06:50,328 --> 00:06:53,360
有些人可能会称这种游戏为专注力，

148
00:06:53,360 --> 00:06:55,620
或者有时也称它为记忆力。

149
00:06:55,620 --> 00:06:57,320
我们将调用我们的记忆。

150
00:06:57,320 --> 00:06:59,420
这将是我们应用程序的名称。

151
00:06:59,420 --> 00:07:01,710
这是一个非常简单的纸牌配对游戏。

152
00:07:01,710 --> 00:07:04,350
你点击卡片，它们会翻转，

153
00:07:04,350 --> 00:07:06,800
你只是想匹配它们。

154
00:07:06,800 --> 00:07:10,030
这些卡片上有表情符号。

155
00:07:10,030 --> 00:07:13,430
我们的万圣节有一个漂亮的橙色主题。

156
00:07:13,430 --> 00:07:14,510
这两张卡不匹配，

157
00:07:14,510 --> 00:07:16,100
所以我不得不继续四处寻找。

158
00:07:16,100 --> 00:07:17,930
 哦，我想是这个，对吧？

159
00:07:17,930 --> 00:07:19,640
所以现在我可以找到一个匹配。

160
00:07:19,640 --> 00:07:20,473
它在那里。

161
00:07:20,473 --> 00:07:23,910
你会得到一个小小的旋转动画。

162
00:07:23,910 --> 00:07:25,700
另请注意，此计时器在后台滴答作响。

163
00:07:25,700 --> 00:07:28,850
该计时器本质上是在

164
00:07:28,850 --> 00:07:32,360
说明这张牌面朝上的时间。

165
00:07:32,360 --> 00:07:35,670
我们显然希望尽可能减少这种情况

166
00:07:35,670 --> 00:07:38,190
并尽快匹配这些卡。

167
00:07:38,190 --> 00:07:41,480
现在，请注意屏幕上没有分数，

168
00:07:41,480 --> 00:07:42,880


169
00:07:42,880 --> 00:07:44,540
因为我将在你的家庭作业中将其留给您，

170
00:07:44,540 --> 00:07:48,110


171
00:07:48,110 --> 00:07:51,640
以根据此计时器的计时以及进行
比赛的速度来决定如何分配积分，

172
00:07:51,640 --> 00:07:55,130
或者在你可以进行比赛时进行处罚 ，

173
00:07:55,130 --> 00:07:56,630
但你没有。

174
00:07:56,630 --> 00:07:58,160
有两张匹配的卡，你会说，

175
00:07:58,160 --> 00:07:59,090
“哦，我没有——

176
00:07:59,090 --> 00:08:00,460
糟糕，我没有匹配那张。

177
00:08:00,460 --> 00:08:02,160
哦不，那和那张一样。”

178
00:08:02,160 --> 00:08:04,452
所以你可能会在这里失去很多分数，

179
00:08:04,452 --> 00:08:08,010
点击周围，试图找到匹配项，

180
00:08:08,010 --> 00:08:09,150
或者你可能会获得分数，

181
00:08:09,150 --> 00:08:10,460
因为你非常擅长记忆，

182
00:08:10,460 --> 00:08:11,293
所以你就像，“哦，是的，

183
00:08:11,293 --> 00:08:13,470
我知道这东西在哪里 .它就在那里，

184
00:08:13,470 --> 00:08:14,827
我要点击并匹配，

185
00:08:14,827 --> 00:08:17,190
但计时器没有计时，等等。”

186
00:08:17,190 --> 00:08:18,350
所以我会把这一切都留给你。

187
00:08:18,350 --> 00:08:20,290


188
00:08:20,290 --> 00:08:24,260
我不想让您偏向任何特定的评分规范实施。

189
00:08:24,260 --> 00:08:26,263
所以这完全取决于你。

190
00:08:27,920 --> 00:08:29,770
这个UI可以做其他事情。

191
00:08:29,770 --> 00:08:31,440
我们可以创建一个新游戏。

192
00:08:31,440 --> 00:08:33,970
我们将重新开始，所有牌面朝下，

193
00:08:33,970 --> 00:08:35,330
然后重新洗牌。

194
00:08:35,330 --> 00:08:37,070
你看这个游戏有很多动画。

195
00:08:37,070 --> 00:08:40,310
动画在SwiftUI中很容易实现。

196
00:08:40,310 --> 00:08:43,540
回到这里，我们在这里看到的这部分UI
让我们可以选择不同的主题。


197
00:08:43,540 --> 00:08:45,590

198
00:08:45,590 --> 00:08:47,470
我们过万圣节。 让我们选择车辆。

199
00:08:47,470 --> 00:08:50,328
现在我们正在匹配车辆表情符号。

200
00:08:50,328 --> 00:08:52,953
那个人在那里有一场比赛。还有一场比赛。

201
00:08:54,020 --> 00:08:56,250
但是，它也可以让您编辑这些主题。

202
00:08:56,250 --> 00:08:58,020
我可以去这里点击编辑，

203
00:08:58,020 --> 00:08:59,347
然后我可以点击这些，

204
00:08:59,347 --> 00:09:02,390
它会打开这个漂亮的用户界面，
用于将表情符号添加到我的主题中，

205
00:09:02,390 --> 00:09:05,010
更改主题的颜色，

206
00:09:05,010 --> 00:09:06,510
也许可以更改匹配卡片的数量，

207
00:09:06,510 --> 00:09:09,700
主题的名称是什么。

208
00:09:09,700 --> 00:09:11,750


209
00:09:11,750 --> 00:09:14,960
你将在你的家庭作业中完成所有这些 UI，百分百。

210
00:09:14,960 --> 00:09:16,370
到我们在几周后完成这项工作时，

211
00:09:16,370 --> 00:09:17,367


212
00:09:17,367 --> 00:09:20,220
您将拥有构建UI的技能，

213
00:09:20,220 --> 00:09:24,491
即使如此复杂。

214
00:09:24,491 --> 00:09:28,310
现在这显然需要构建相当多的 UI。

215
00:09:28,310 --> 00:09:31,350


216
00:09:31,350 --> 00:09:33,550
我们不会在这周剩下的讲座时间里建立这一切。

217
00:09:33,550 --> 00:09:35,260
我们将通过构建其中的一些，

218
00:09:35,260 --> 00:09:38,410
一点点来开始。

219
00:09:38,410 --> 00:09:40,010
在这个模拟器中，

220
00:09:40,010 --> 00:09:42,413
我在这里有一个Memorize版本，

221
00:09:42,413 --> 00:09:44,730


222
00:09:44,730 --> 00:09:47,980
这将是我们将在本周的讲座中构建的内容。

223
00:09:47,980 --> 00:09:51,210
你可以看到它有卡片，我可以点击它们，

224
00:09:51,210 --> 00:09:53,380
它们会翻转，
尽管它们没有动画。

225
00:09:53,380 --> 00:09:55,520
显然那里没有计时器。

226
00:09:55,520 --> 00:09:58,940
另外，如果我把所有的牌都翻过来，

227
00:09:58,940 --> 00:10:00,961
你会发现没有两张牌是一样的。

228
00:10:00,961 --> 00:10:03,620
这些都是12张完全不同的卡片。

229
00:10:03,620 --> 00:10:05,680
所以，我们不能玩匹配游戏，

230
00:10:05,680 --> 00:10:07,610
因为我们没有匹配的卡片。

231
00:10:07,610 --> 00:10:10,830
总的来说，玩配对游戏的整个逻辑，

232
00:10:10,830 --> 00:10:12,400
我们将在下周进行。

233
00:10:12,400 --> 00:10:14,470
我们本周所做的只是尝试

234
00:10:14,470 --> 00:10:17,720
开始构建我们的UI
并让它看起来像这样。

235
00:10:17,720 --> 00:10:19,870
显然我们并没有

236
00:10:19,870 --> 00:10:21,740
在那里做任何复杂的用户界面，

237
00:10:21,740 --> 00:10:23,940
我们只是想把我们的卡片放在这里。

238
00:10:23,940 --> 00:10:25,330
我们将在这里放一些

239
00:10:25,330 --> 00:10:27,900
在我们的最终版本中没有的东西，

240
00:10:27,900 --> 00:10:30,516
比如这个加号按钮，它添加了一张卡片。

241
00:10:30,516 --> 00:10:31,940
添加更多卡片。

242
00:10:31,940 --> 00:10:34,040
此外，我们的UI将滚动，

243
00:10:34,040 --> 00:10:36,600
因为我们可以在这里找到太多的优点，

244
00:10:36,600 --> 00:10:39,170
以至于卡片不再适合。

245
00:10:39,170 --> 00:10:42,050
而这里不是这样。 顺便说一句，

246
00:10:42,050 --> 00:10:44,540
如果我们把它旋转起来，那真的很明显。

247
00:10:44,540 --> 00:10:47,560
此处的此按钮将旋转到横向模式，

248
00:10:47,560 --> 00:10:50,620
并且卡片会稍微调整自己的大小，

249
00:10:50,620 --> 00:10:53,350
以便它们更适合空间。

250
00:10:53,350 --> 00:10:55,710
在我们旋转的版本中，

251
00:10:55,710 --> 00:10:58,240
它仍然有效，但我们必须滚动，

252
00:10:58,240 --> 00:10:59,550
因为我们无法容纳所有卡片。

253
00:10:59,550 --> 00:11:02,933
我们的卡片在这里是固定大小的。

254
00:11:04,180 --> 00:11:06,760
我原本打算让你

255
00:11:06,760 --> 00:11:07,940
在作业中在这里做一个洗牌按钮，

256
00:11:07,940 --> 00:11:10,210
这会洗牌。 但我实际上

257
00:11:10,210 --> 00:11:12,840
决定让你做一些更雄心勃勃的事情，

258
00:11:12,840 --> 00:11:14,780
即洗牌，

259
00:11:14,780 --> 00:11:18,850
同时提供一个非常非常简单的主题选择器。

260
00:11:18,850 --> 00:11:23,080
与我们在此处左侧看到的主题选择器不同，

261
00:11:23,080 --> 00:11:25,330
它只是让您可以使用

262
00:11:25,330 --> 00:11:27,330
我们本周所学的东西。

263
00:11:27,330 --> 00:11:29,320
此外，您可能注意到shuffle正在做一些动画，

264
00:11:29,320 --> 00:11:30,800


265
00:11:30,800 --> 00:11:33,140
但我决定暂时将其推迟，

266
00:11:33,140 --> 00:11:34,700
因此您不必

267
00:11:34,700 --> 00:11:36,180
为作业中的shuffle按钮制作动画，

268
00:11:36,180 --> 00:11:37,270


269
00:11:37,270 --> 00:11:41,650
我们将讨论几周后所有关于动画的内容。

270
00:11:41,650 --> 00:11:45,130
我们用来构建所有这些的工具称为Xcode。

271
00:11:45,130 --> 00:11:48,370
它是完成所有这些事情的一站式购物，

272
00:11:48,370 --> 00:11:50,983
无论是编辑代码、运行它、

273
00:11:50,983 --> 00:11:55,470
在构建它时查看UI、调试它等等。

274
00:11:55,470 --> 00:11:56,790
都在一个地方。

275
00:11:56,790 --> 00:11:58,090
让我们在这里简单谈谈

276
00:11:58,090 --> 00:11:59,970
我们是如何掌握Xcode的。

277
00:11:59,970 --> 00:12:00,817
我们需要Xcode。

278
00:12:00,817 --> 00:12:02,420
而且既然是Mac应用，

279
00:12:02,420 --> 00:12:05,080
我们当然可以去Mac App Store。

280
00:12:05,080 --> 00:12:07,290
如果您访问Mac App Store 
281
00:12:07,290 --> 00:12:10,850
并转到搜索栏并输入Xcode，

282
00:12:10,850 --> 00:12:13,247
那么你将获得最匹配的Xcode。

283
00:12:13,247 --> 00:12:14,380
如果你点击它，下载。 

284
00:12:14,380 --> 00:12:17,027
这就是说，只需单击它，

285
00:12:17,027 --> 00:12:18,083
你就可以启动并运行。

286
00:12:18,083 --> 00:12:20,520
这是一款免费的应用程序，无需任何费用，

287
00:12:20,520 --> 00:12:25,520
而且你可以以每年99美元的价格


288
00:12:26,140 --> 00:12:29,000
加入Apple的开发者计划。 


289
00:12:29,000 --> 00:12:31,040
稍后我会讨论你会得到什么，但这不是必需的。

290
00:12:31,040 --> 00:12:32,200


291
00:12:32,200 --> 00:12:34,290
本课程不需要，你在本课程中所做的任何事情，

292
00:12:34,290 --> 00:12:36,550
我们在这里构建的这个应用程序，

293
00:12:36,550 --> 00:12:39,380


294
00:12:40,830 --> 00:12:43,760
都不需要加入Apple的开发人员计划。

295
00:12:43,760 --> 00:12:44,593
所以它是免费的。

296
00:12:44,593 --> 00:12:45,910
所以一切都是免费的。

297
00:12:45,910 --> 00:12:47,950
现在，如果你有点大胆和冒险，

298
00:12:47,950 --> 00:12:50,580
并且想尝试Xcode的beta版本，

299
00:12:50,580 --> 00:12:51,870


300
00:12:51,870 --> 00:12:53,620
当然他们总是每隔几周就会推出beta版本，

301
00:12:53,620 --> 00:12:54,830
当然欢迎你这样做。

302
00:12:54,830 --> 00:12:56,280
我将简要地向您展示如何做到这一点。

303
00:12:56,280 --> 00:13:01,280
只需打开您的 Safari，
访问developer.apple.com。

304
00:13:01,690 --> 00:13:03,460
事实上，我们可以直接访问

305
00:13:03,460 --> 00:13:06,310
developer.apple.com/downloads，

306
00:13:06,310 --> 00:13:08,440
这可能是到达那里的最快方式。

307
00:13:08,440 --> 00:13:10,420
您可以看到有Mac OS和iOS的测试版软件下载。


308
00:13:10,420 --> 00:13:14,442

而且，在此处的应用程序下，

309
00:13:14,442 --> 00:13:17,684
您将看到Xcode 12.5 beta 3。

310
00:13:17,684 --> 00:13:19,983
这将再次随着时间的推移而更新。

311
00:13:19,983 --> 00:13:22,380
您只需单击下载即可运行它。

312
00:13:22,380 --> 00:13:25,910
我在这门课程中所做的一切都不需要这个测试版，

313
00:13:25,910 --> 00:13:27,690
所以如果你只想使用应用商店的版本，

314
00:13:27,690 --> 00:13:28,910
你就很好了。

315
00:13:28,910 --> 00:13:30,590
也许从那个开始，

316
00:13:30,590 --> 00:13:33,300
然后当你变得更加自信
并且想要处于事物的最前沿时，

317
00:13:33,300 --> 00:13:35,280
如果您愿意，

318
00:13:35,280 --> 00:13:38,093
可以随时切换到测试版。

319
00:13:41,310 --> 00:13:44,130
一旦我们在我们的机器上安装了Xcode，

320
00:13:44,130 --> 00:13:45,680
我们通过点击它来启动它。

321
00:13:45,680 --> 00:13:48,370
我碰巧在这里运行测试版。

322
00:13:48,370 --> 00:13:51,040
当我们这样做时，我们会得到这个启动画面。

323
00:13:51,040 --> 00:13:53,370
Beta版或普通版，

324
00:13:53,370 --> 00:13:54,610
你总会看到这个闪屏。

325
00:13:54,610 --> 00:13:57,330
Xcode中的一个非常简单的起点：

326
00:13:57,330 --> 00:14:00,360
在右边，我们有我们最近的所有项目。

327
00:14:00,360 --> 00:14:02,580
我们一直在做的事情将存储在这里。

328
00:14:02,580 --> 00:14:04,790
然后在左侧，我们只有三个选项

329
00:14:04,790 --> 00:14:08,840
来启动新项目或查找

330
00:14:08,840 --> 00:14:10,880
不在此列表中的现有项目，这非常罕见。

331
00:14:10,880 --> 00:14:14,070
我们从事的所有项目都可靠地保存在这里，

332
00:14:14,070 --> 00:14:17,190
所以我们通常是这样打开它的。

333
00:14:17,190 --> 00:14:19,510
有两种方法可以真正创建一个全新的项目。

334
00:14:19,510 --> 00:14:22,097
一种是在这里创建它。这就是第一个。

335
00:14:22,097 --> 00:14:24,210


336
00:14:24,210 --> 00:14:27,650
第二个是克隆某个位于源代码存储库中的项目。

337
00:14:27,650 --> 00:14:31,020
我将在本季度晚些时候讨论一下
源代码控制和存储库，

338
00:14:31,020 --> 00:14:33,700


339
00:14:33,700 --> 00:14:35,490
但现在，

340
00:14:35,490 --> 00:14:38,070


341
00:14:38,070 --> 00:14:40,597
显然我们将通过单击“创建一个新的Xcode项目”
来创建我们的第一个项目。

342
00:14:40,597 --> 00:14:42,881
这个“打开一个项目或文件”在这里，

343
00:14:42,881 --> 00:14:44,830
实际上不必这样做。

344
00:14:44,830 --> 00:14:48,380
这些东西都会在这里结束。

345
00:14:48,380 --> 00:14:51,040
单击“创建一个新的Xcode 项目”。

346
00:14:51,040 --> 00:14:52,256
它立即说，

347
00:14:52,256 --> 00:14:54,650
你想创建什么样的项目？

348
00:14:54,650 --> 00:14:57,700
因为Xcode不仅可以构建我们正在构建的iOS应用程序，

349
00:14:57,700 --> 00:15:00,240


350
00:15:00,240 --> 00:15:05,240
还可以构建Mac OS 应用程序、Apple
Watch 应用程序、Apple TV 应用程序，

351
00:15:05,840 --> 00:15:08,890


352
00:15:08,890 --> 00:15:11,130
甚至可以在Mac OS和iOS上运行的多平台应用程序。

353
00:15:11,130 --> 00:15:13,470



354
00:15:13,470 --> 00:15:16,040
我们将在本季度晚些时候为我们构建的第二个大型应用程序这样做。

355
00:15:16,040 --> 00:15:18,410
但是，今天我们要做iOS应用程序。

356
00:15:18,410 --> 00:15:22,270
即使在iOS中，这里也有不同类型的应用程序。

357
00:15:22,270 --> 00:15:27,270
大多数时候，
我们只做基本的“应用程序”。

358
00:15:27,440 --> 00:15:28,481
但是，在本季度晚些时候，

359
00:15:28,481 --> 00:15:29,720
我们将制作一个“文档应用程序”，

360
00:15:29,720 --> 00:15:32,169
这里还有其他类型。 

361
00:15:32,169 --> 00:15:35,280
您可能会为您的最终项目探索其中的一些。

362
00:15:35,280 --> 00:15:38,117
但我们要做 iOS应用程序。 
只需单击此处和此处，

363
00:15:38,117 --> 00:15:41,460
并确保在构建应用程序时执行此操作。 

364
00:15:41,460 --> 00:15:44,620
如果你想继续，你可能想在这里暂停一下，

365
00:15:44,620 --> 00:15:47,860
然后去获取Xcode。

366
00:15:47,860 --> 00:15:50,050
如果这样做，

367
00:15:50,050 --> 00:15:53,183
请务必在单击“下一步”之前单击“iOS”，
然后单击“应用程序”。

368
00:15:54,452 --> 00:15:55,285
当你这样做时，

369
00:15:55,285 --> 00:15:56,480
它会问你一些

370
00:15:56,480 --> 00:15:59,130
关于你想要构建的iOS应用程序的问题。

371
00:15:59,130 --> 00:16:01,710
第一个问题：你想怎么称呼这个东西？

372
00:16:01,710 --> 00:16:04,893
我们知道我们正在调用我们的应用程序Memorize。

373
00:16:05,730 --> 00:16:07,580
这里的第二件事是团队。

374
00:16:07,580 --> 00:16:10,450
这是致力于此的开发团队。

375
00:16:10,450 --> 00:16:12,330
好吧，那将是你。

376
00:16:12,330 --> 00:16:15,270
当你运行它时，除非你以前使用过 Xcode，

377
00:16:15,270 --> 00:16:16,940
否则它可能会说

378
00:16:16,940 --> 00:16:19,850
“创建团队”之类的东西。


379
00:16:19,850 --> 00:16:22,490
你将单击它来创建一个开发团队。

380
00:16:22,490 --> 00:16:24,910

创建一个开发团队真的很容易，

381
00:16:24,910 --> 00:16:27,340
你只需要一个Apple ID。

382
00:16:27,340 --> 00:16:30,270
这只是你正常的iCloud登录。

383
00:16:30,270 --> 00:16:31,980
再说一次，它不会花任何钱。

384
00:16:31,980 --> 00:16:33,180
你只要去

385
00:16:33,180 --> 00:16:35,960


386
00:16:35,960 --> 00:16:39,223
那个iCloud Apple ID注册这个开发团队就可以了。

387
00:16:39,223 --> 00:16:40,823
然后你就可以开始跑步了。

388
00:16:42,760 --> 00:16:44,800
接下来，您将有一个字符串，

389
00:16:44,800 --> 00:16:48,030
这个组织标识符。你就是组织。

390
00:16:48,030 --> 00:16:49,750
基本上，这是你工作的组织，

391
00:16:49,750 --> 00:16:51,090
但你是学生。

392
00:16:51,090 --> 00:16:53,040
如果你不是斯坦福大学的学生，

393
00:16:53,040 --> 00:16:55,410
这可能就是你工作的公司。

394
00:16:55,410 --> 00:16:59,290


395
00:16:59,290 --> 00:17:01,010
这必须确定你正在为此工作的组织。

396
00:17:01,010 --> 00:17:03,910
如果你是个人，


397
00:17:05,300 --> 00:17:08,490
我真的建议你在这里使用所谓的反向DNS表示法。

398
00:17:08,490 --> 00:17:11,180
也许你的电子邮件地址，
或者如果你是斯坦福大学的学生，

399
00:17:11,180 --> 00:17:16,172
edu.stanford.cs193p.[你的 SUNetID]

400
00:17:16,172 --> 00:17:17,440
而不是讲师。

401
00:17:17,440 --> 00:17:19,923

如果你愿意，也许你甚至可以跳过CS193p。

402
00:17:19,923 --> 00:17:21,560
但是，你只想在这里挑选

403
00:17:21,560 --> 00:17:24,183
其他人不会挑选的东西。

404
00:17:24,183 --> 00:17:25,190
如果您为一家公司工作，

405
00:17:25,190 --> 00:17:29,630
这可能是您公司的网站名称倒序，

406
00:17:29,630 --> 00:17:32,960
甚至是你公司的网站名称倒序，

407
00:17:32,960 --> 00:17:35,270
然后是你所在公司的组。

408
00:17:35,270 --> 00:17:38,090
这必须是一个独特的东西，

409
00:17:38,090 --> 00:17:40,663
可以识别正在开发这个应用程序的小组。

410
00:17:41,690 --> 00:17:45,650
Xcode快速将名称与该名称组合

411
00:17:45,650 --> 00:17:47,450
以创建此包标识符，

412
00:17:47,450 --> 00:17:50,040
该标识符是此应用程序的唯一ID。

413
00:17:50,040 --> 00:17:51,880
完全有道理。

414
00:17:51,880 --> 00:17:56,880
最后三个小选择框

415
00:17:57,440 --> 00:18:01,120



416
00:18:01,120 --> 00:18:04,250
让你在开发iOS应用程序的新方法SwiftUI


417
00:18:04,250 --> 00:18:06,880
和称为故事板的旧方法之间进行选择。

418
00:18:06,880 --> 00:18:08,830
我只有10周的时间向你展示这些东西，

419
00:18:08,830 --> 00:18:10,643
所以我不能同时向你展示。

420
00:18:10,643 --> 00:18:13,270
新方法，它是两年前才推出的非常新的方法，

421
00:18:13,270 --> 00:18:16,890

但它非常强大，

422
00:18:16,890 --> 00:18:19,230


423
00:18:19,230 --> 00:18:22,380
并且还受益于旧方法的所有学习。

424
00:18:22,380 --> 00:18:23,800
当你创建一个应用程序时，

425
00:18:23,800 --> 00:18:26,220
你总是会打开这三个按钮。

426
00:18:26,220 --> 00:18:28,278
SwiftUI，新方式，SwiftUI App，

427
00:18:28,278 --> 00:18:30,500
这是新方式

428
00:18:30,500 --> 00:18:32,710
此外，

429
00:18:32,710 --> 00:18:34,410
你可以将新方式与创建应用程序的旧方式混合使用。

430
00:18:34,410 --> 00:18:36,960
这有点奇怪，但你可以做到，我们不会。

431
00:18:36,960 --> 00:18:39,230
我们总是会做SwiftUI App。

432
00:18:39,230 --> 00:18:41,840
既然我们选择了这些，

433
00:18:41,840 --> 00:18:44,210
对于语言，只有一个选择，那就是Swift。

434
00:18:44,210 --> 00:18:46,890
SwiftUI完全依赖于Swift语言，

435
00:18:46,890 --> 00:18:48,227
这是一种新的编程语言，

436
00:18:48,227 --> 00:18:50,860
我不会假设你知道。

437
00:18:50,860 --> 00:18:53,330


438
00:18:53,330 --> 00:18:55,997
我将在整个季度从头开始向你展示这种语言。

439
00:18:55,997 --> 00:18:58,267
如果我们在这里选择了旧方法，

440
00:18:58,267 --> 00:19:00,630
那么我们将在这里选择另一种语言，

441
00:19:00,630 --> 00:19:02,550
称为Objective-C，

442
00:19:02,550 --> 00:19:05,360
它是最初编写旧方法的语言。

443
00:19:05,360 --> 00:19:07,610
但同样，在这门课程中一直都是 Swift，

444
00:19:07,610 --> 00:19:09,400
所以我们


445
00:19:09,400 --> 00:19:10,850
在这些Swift设置中总是会有这些按钮。

446
00:19:11,850 --> 00:19:13,900
最后一件事：关于这里的这些开关，

447
00:19:13,900 --> 00:19:16,700
确保它们在第一个应用程序中全部关闭，

448
00:19:16,700 --> 00:19:19,670
但我们稍后将看看这个核心数据的东西。

449
00:19:19,670 --> 00:19:21,570
那是一个面向对象的数据库。

450
00:19:21,570 --> 00:19:23,340


451
00:19:23,340 --> 00:19:24,690
我可能没有时间向您展示SwiftUI中的测试框架，

452
00:19:24,690 --> 00:19:27,083
但它非常棒。

453
00:19:28,458 --> 00:19:31,610
它不仅可以让你测试后端代码，

454
00:19:31,610 --> 00:19:33,510
还可以测试您的UI，

455
00:19:33,510 --> 00:19:36,710
以确保您的UI看起来像它应该的那样。

456
00:19:36,710 --> 00:19:39,640
但是，请再次，

457
00:19:39,640 --> 00:19:42,760
所有这些都为这里的第一个版本，记忆。

458
00:19:42,760 --> 00:19:44,560
当我们点击下一个时，

459
00:19:44,560 --> 00:19:47,520
现在它只想知道你要将这个东西
放在你的文件系统中的什么位置？

460
00:19:47,520 --> 00:19:48,940
我强烈建议将它放在您的主目录中

461
00:19:48,940 --> 00:19:52,230
名为Developer的文件夹中。

462
00:19:52,230 --> 00:19:54,720
所以你所有的项目都应该

463
00:19:54,720 --> 00:19:56,960
收集在你的主目录Developer中。

464
00:19:56,960 --> 00:19:58,820
这是放置它的规范位置。

465
00:19:58,820 --> 00:20:00,190
你可以看到

466
00:20:01,302 --> 00:20:04,540
Finder甚至在上面放了一个锤子图标。

467
00:20:04,540 --> 00:20:08,197
它认为这是一种标准的文件夹。

468
00:20:08,197 --> 00:20:10,500
在这里，

469
00:20:10,500 --> 00:20:12,790
我们有我在开始时谈到的源代码控制，

470
00:20:12,790 --> 00:20:16,141
你将这些东西存储在存储库中，

471
00:20:16,141 --> 00:20:19,850


472
00:20:19,850 --> 00:20:21,540
这是我们将在本季度晚些时候简要讨论的内容。

473
00:20:21,540 --> 00:20:24,250
源代码控制作为个人

474
00:20:24,250 --> 00:20:27,600
在开发应用程序时非常适合对应用程序进行版本控制，

475
00:20:27,600 --> 00:20:29,900
但它对团队来说确实很有价值。

476
00:20:29,900 --> 00:20:32,650
当你和团队一起做
一个项目时，

477
00:20:32,650 --> 00:20:35,010
五个程序员或
其他人在一个应用

478
00:20:35,010 --> 00:20:37,715
程序上工作，甚至一百个程序员
在一个应用程序上工作，

479
00:20:37,715 --> 00:20:40,150
你怎么不互相踩？

480
00:20:40,150 --> 00:20:43,670
整个源代码控制
提供了一种机制，

481
00:20:43,670 --> 00:20:46,080
用于检查您的
代码、进行更改、将

482
00:20:46,080 --> 00:20:47,780
其重新签入，
确保它不会

483
00:20:47,780 --> 00:20:49,180
与

484
00:20:49,180 --> 00:20:51,087
您团队中其他程序员所做的事情发生冲突，等等。

485
00:20:51,087 --> 00:20:54,160
同样，我们将
在本季度晚些时候简要讨论这一点，

486
00:20:54,160 --> 00:20:57,640
但我们绝对希望这开始。

487
00:20:57,640 --> 00:21:00,920
我说肯定的，但我
打算把它关掉。

488
00:21:00,920 --> 00:21:03,530
因此，如果您
跟随，您可能会认为如果您戴上它，

489
00:21:03,530 --> 00:21:07,090
您的看起来会略有
不同。

490
00:21:07,090 --> 00:21:11,010
所以让我们把它关掉
，点击创建，瞧，

491
00:21:11,010 --> 00:21:12,480
它为我们创建了我们的应用程序。

492
00:21:12,480 --> 00:21:16,460
这是我们的第一个 iOS 应用程序。

493
00:21:16,460 --> 00:21:18,866
恭喜，你已经
构建了你的第一个 iOS 应用程序。

494
00:21:18,866 --> 00:21:21,210
这是 Xcode 的主屏幕。

495
00:21:21,210 --> 00:21:23,970
你将在这里度过整个
季度的生活，

496
00:21:23,970 --> 00:21:26,000
所以我将花
一些时间谈论

497
00:21:26,000 --> 00:21:27,730
这一切。

498
00:21:27,730 --> 00:21:29,770
我
将从顶部

499
00:21:29,770 --> 00:21:32,747
的这个有趣的小按钮组合开始。

500
00:21:32,747 --> 00:21:36,260
这就是您运行应用程序的方式。

501
00:21:36,260 --> 00:21:37,490
所以你要做的第一件事

502
00:21:37,490 --> 00:21:39,720
就是选择你想在哪里
运行你的应用程序。

503
00:21:39,720 --> 00:21:40,730
就是这个。 现在，

504
00:21:40,730 --> 00:21:42,840
它说的是 iPad touch（第 7 代）。

505
00:21:42,840 --> 00:21:45,170
如果我运行它，它将运行它，

506
00:21:45,170 --> 00:21:46,530
但我要点击它

507
00:21:46,530 --> 00:21:48,710
，你可以看到我
可以选择在

508
00:21:48,710 --> 00:21:50,900
连接到我的 Mac 的 iOS 设备上运行它

509
00:21:50,900 --> 00:21:53,080
（我现在没有任何连接）

510
00:21:53,080 --> 00:21:54,220
或者我可以在

511
00:21:54,220 --> 00:21:56,260
我们看到的那些很棒的模拟器之一中运行它。

512
00:21:56,260 --> 00:21:58,690
有 iPhone 8 模拟器，iPhone 11。

513
00:21:58,690 --> 00:22:00,830
我们将

514
00:22:00,830 --> 00:22:05,760
在我最喜欢的 iPhone 的 iPhone 12 mini 上运行我们的应用程序。

515
00:22:05,760 --> 00:22:07,690
您只需选择要运行它的位置

516
00:22:07,690 --> 00:22:09,350
，然后按此播放按钮，

517
00:22:09,350 --> 00:22:11,210
然后在完成后按停止。

518
00:22:11,210 --> 00:22:12,120
所以播放并停止。

519
00:22:12,120 --> 00:22:14,034
所以让我们继续玩吧。

520
00:22:14,034 --> 00:22:19,034
它将推出这款
iPhone 12 mini 模拟器。

521
00:22:20,550 --> 00:22:21,550
它在那里。

522
00:22:21,550 --> 00:22:23,750
然后它将在其上安装我们的应用程序

523
00:22:23,750 --> 00:22:25,523
并运行该应用程序。

524
00:22:26,460 --> 00:22:28,640
它在那里。 它只是说“你好，世界！”。

525
00:22:28,640 --> 00:22:32,930
现在，那些
回头看我们的代码的人

526
00:22:32,930 --> 00:22:35,220
可能看到了“Hello,
world!”。 就在那儿

527
00:22:35,220 --> 00:22:37,600
，你就像“嗯，我敢打赌
这个应用程序会说‘你好，世界！’

528
00:22:37,600 --> 00:22:39,550
”事实上它确实说“你好，世界！”。

529
00:22:39,550 --> 00:22:41,529
这就是这个应用程序所说的。

530
00:22:41,529 --> 00:22:45,700
否则，它只是很大的空白。

531
00:22:45,700 --> 00:22:47,290
这很酷，我们可以做到这一点

532
00:22:47,290 --> 00:22:49,970
，我们可以做
旋转之类的事情，这很好。

533
00:22:49,970 --> 00:22:52,000
它保持自动居中。

534
00:22:52,000 --> 00:22:53,660
我们会发现这个

535
00:22:53,660 --> 00:22:56,310
我们旋转的东西和我们的 UI 变化，

536
00:22:56,310 --> 00:22:58,150
我们需要为此做很少的代码。

537
00:22:58,150 --> 00:23:00,550
SwiftUI 几乎为我们处理了这些，

538
00:23:00,550 --> 00:23:03,290
正确地居中以及所有这些。

539
00:23:03,290 --> 00:23:05,830
然后当我们完成模拟我们的应用程序

540
00:23:05,830 --> 00:23:06,760
在此处运行时，

541
00:23:06,760 --> 00:23:08,320
这又是一个完整的 iPhone 模拟器。

542
00:23:08,320 --> 00:23:11,910
我可以
在这里切换并运行设置

543
00:23:11,910 --> 00:23:16,030
，然后返回，切换回
我的应用程序，在那里进行完全模拟。

544
00:23:16,030 --> 00:23:19,093
所以当我们完成时，我们按下
停止。 它停止运行。

545
00:23:20,240 --> 00:23:22,930
我隐藏菜单
只是为了给我们更多空间，

546
00:23:22,930 --> 00:23:26,500
但显然 Xcode 中有
很多菜单

547
00:23:26,500 --> 00:23:27,603
，我们将使用它们。

548
00:23:27,603 --> 00:23:29,810
显然，随着季度的进行，

549
00:23:29,810 --> 00:23:32,500
您将在我们进行的过程中学习它们。

550
00:23:32,500 --> 00:23:35,940

看到如此多的菜单项

551
00:23:35,940 --> 00:23:39,160
和如此多的东西可能会令人生畏，但
我们将再次慢慢地揭开它们的面纱。

552
00:23:39,160 --> 00:23:41,510
这一切都不会太
吓人。

553
00:23:42,680 --> 00:23:43,700
这里有一个小小的状态奇迹，

554
00:23:43,700 --> 00:23:45,100
它只是告诉你发生了什么。

555
00:23:45,100 --> 00:23:47,040
在这里，我们刚刚完成了 Memorize 的运行。

556
00:23:47,040 --> 00:23:49,693
它会说它什么时候编译
和所有这些东西。

557
00:23:50,895 --> 00:23:54,840
让我们看看
左边的这个蓝色区域。

558
00:23:54,840 --> 00:23:59,510
这被称为导航器
，它按照它所说的做：

559
00:23:59,510 --> 00:24:02,020
它让你导航你的应用程序。

560
00:24:02,020 --> 00:24:04,620
它可以让您
以多种不同的方式导航它。

561
00:24:04,620 --> 00:24:06,930
此处的这些小图标
可让您

562
00:24:06,930 --> 00:24:08,960
选择不同的导航方式

563
00:24:08,960 --> 00:24:11,488
，此处的默认设置是
按文件导航。

564
00:24:11,488 --> 00:24:14,470
这些是我们应用程序中的所有文件
。

565
00:24:14,470 --> 00:24:16,630
这四个文件是 Xcode 为我们创建的

566
00:24:16,630 --> 00:24:18,280
，用于帮助我们入门

567
00:24:18,280 --> 00:24:19,530
，我稍后将实际查看所有这

568
00:24:19,530 --> 00:24:21,310
四个文件。

569
00:24:21,310 --> 00:24:23,240
但是我们也可以

570
00:24:23,240 --> 00:24:25,810
通过搜索整个项目来导航其他方式，

571
00:24:25,810 --> 00:24:27,340
或者如果我们正在调试，我们可以

572
00:24:27,340 --> 00:24:30,200
查看所有断点等。

573
00:24:30,200 --> 00:24:33,290
我们将看到这些
不同的导航方式。

574
00:24:33,290 --> 00:24:35,780
这里的所有部分都可以调整大小。

575
00:24:35,780 --> 00:24:37,320
只需用鼠标抓住它

576
00:24:37,320 --> 00:24:39,350
，您就可以根据需要将其放大或缩小

577
00:24:39,350 --> 00:24:41,410
以分配空间。

578
00:24:41,410 --> 00:24:44,653
您还可以
使用这个小按钮隐藏和显示。

579
00:24:46,050 --> 00:24:49,020
很多时候，一旦你
深入进行了一些编辑，

580
00:24:49,020 --> 00:24:51,580
你真的不需要


581
00:24:51,580 --> 00:24:53,320
在这里来回切换文件，特别是因为

582
00:24:53,320 --> 00:24:55,747
你会看到标签
沿着这里的顶部发展，

583
00:24:55,747 --> 00:24:58,410
就像这个东西
说 ContentView.swift

584
00:24:58,410 --> 00:25:01,790
，您
最近编辑的文件位于选项卡中。

585
00:25:01,790 --> 00:25:04,240
所以你真的
不需要这个，

586
00:25:04,240 --> 00:25:06,890
除非你要搜索
或类似的东西。

587
00:25:08,010 --> 00:25:10,410
现在在右边，这里的这个区域，

588
00:25:10,410 --> 00:25:12,210
这个灰色的东西叫做 Inspector。 稍后

589
00:25:12,210 --> 00:25:15,020
我将向您展示
这一点。

590
00:25:15,020 --> 00:25:18,020
在中心，这两个

591
00:25:18,020 --> 00:25:20,390
窗格是主编辑窗口。

592
00:25:20,390 --> 00:25:22,830
通常，
您的代码将位于左侧，

593
00:25:22,830 --> 00:25:24,890
并且您将拥有一个甚至

594
00:25:24,890 --> 00:25:28,130
多个其他辅助窗口。

595
00:25:28,130 --> 00:25:31,800
这里这个特别的小空间
非常酷。

596
00:25:31,800 --> 00:25:36,800
这是预览器。
预览器预览您的 UI。

597
00:25:36,900 --> 00:25:39,395
它实际上向您
展示了您的 UI 的外观，

598
00:25:39,395 --> 00:25:42,170
而无需在模拟器上运行它

599
00:25:42,170 --> 00:25:45,340
，而且它
主要是实时地向您展示。

600
00:25:45,340 --> 00:25:48,200
它偶尔会暂停。
它在这里说

601
00:25:48,200 --> 00:25:50,130
“自动预览更新已暂停”

602
00:25:50,130 --> 00:25:53,130
这就是为什么我们没有
看到我们的“你好，世界！”

603
00:25:53,130 --> 00:25:55,470
这里的代码出现了。

604
00:25:55,470 --> 00:25:57,640
但是，我们可以
随时使用“恢复”恢复它。

605
00:25:57,640 --> 00:26:00,010
当我们恢复时，它本质上就像在这里

606
00:26:00,010 --> 00:26:03,500
启动一个小模拟器
。

607
00:26:03,500 --> 00:26:06,550
我们可以缩小
一点，我们可以看到我们的 UI。

608
00:26:06,550 --> 00:26:08,850
这是我们的小“你好，世界！” 用户界面。

609
00:26:08,850 --> 00:26:13,160

如果我们愿意，我们可以更好地划分空间。

610
00:26:13,160 --> 00:26:16,080
我们将在进行开发时看到使用此预览版

611
00:26:16,080 --> 00:26:17,740
。

612
00:26:17,740 --> 00:26:20,863
它总是
会为我们预览。

613
00:26:20,863 --> 00:26:24,363
这是一个非常强大、
非常棒的系统。

614
00:26:25,220 --> 00:26:28,090
在顶部，我们
还看到有一条小

615
00:26:28,090 --> 00:26:30,310
线只是说明我们在哪里，

616
00:26:30,310 --> 00:26:32,100
特别是我们的光标在哪里。

617
00:26:32,100 --> 00:26:34,080
如果我点击这里，它实际上

618
00:26:34,080 --> 00:26:35,210
是在说我们在这个身体里。

619
00:26:35,210 --> 00:26:37,070
如果我单击此处，则表示

620
00:26:37,070 --> 00:26:40,370
我们在 ContentView_Previews 中。

621
00:26:40,370 --> 00:26:42,840
您甚至可以单击
它并四处导航，

622
00:26:42,840 --> 00:26:45,163
将光标四处
跳动，将其跳到底部，将

623
00:26:45,163 --> 00:26:47,640
其跳回顶部，等等。

624
00:26:47,640 --> 00:26:50,733
这就是
我们的光标所在的位置。

625
00:26:51,595 --> 00:26:53,170


626
00:26:53,170 --> 00:26:55,820
关于这三件事

627
00:26:55,820 --> 00:26:58,220
，预览、我们的主要代码编辑

628
00:26:58,220 --> 00:27:01,190
和这个检查器，其中一件很酷的事情是
它们将保持同步。

629
00:27:01,190 --> 00:27:04,050
如果我
点击这里的这行代码，

630
00:27:04,050 --> 00:27:06,991
它不仅会选择

631
00:27:06,991 --> 00:27:08,600
Text("Hello, world!")，

632
00:27:08,600 --> 00:27:12,570
而且会选择
"Hello, world!"。

633
00:27:12,570 --> 00:27:16,120
这里有一条蓝线的文本
，它创建了一个检查器，

634
00:27:16,120 --> 00:27:20,010
这里是某种 UI，
用于检查或编辑我选择

635
00:27:20,010 --> 00:27:22,460
的这个东西的属性
。

636
00:27:22,460 --> 00:27:25,870
如果我点击离开，那么它
会在此处停止选择它。

637
00:27:25,870 --> 00:27:27,370
什么都不需要检查。

638
00:27:27,370 --> 00:27:28,400
点击返回。

639
00:27:28,400 --> 00:27:29,340
它正在做。

640
00:27:29,340 --> 00:27:32,030
如果我点击离开，我也可以

641
00:27:32,030 --> 00:27:33,980
在这里双击它，它会在这里选择它。

642
00:27:33,980 --> 00:27:36,690
在这里显示并在此处选择它。

643
00:27:36,690 --> 00:27:38,190
这些东西是联系在一起的。

644
00:27:38,190 --> 00:27:41,370
他们总是向你展示，
除非这件事被暂停，

645
00:27:41,370 --> 00:27:44,863
否则他们总是向你
展示其他三个窗格中的内容。

646
00:27:45,740 --> 00:27:48,110
我们可以

647
00:27:48,110 --> 00:27:49,385
在任何这些窗格中编辑或更改内容。

648
00:27:49,385 --> 00:27:51,960
例如，我们有“你好，世界！” 在这里

649
00:27:51,960 --> 00:27:56,480
，如果我们说“你好，
CS193p！”会怎样？ 看那个

650
00:27:56,480 --> 00:27:59,510
，这里变了，这里变了。

651
00:27:59,510 --> 00:28:00,927
我们可以在这里改变它。

652
00:28:00,927 --> 00:28:03,850
我们可以说“你好，CS193p！”

653
00:28:03,850 --> 00:28:06,100
这里改了，这里改了。

654
00:28:06,100 --> 00:28:09,355
真正酷的是
当我在这里编辑它时，

655
00:28:09,355 --> 00:28:12,470
它在这里实时变化

656
00:28:12,470 --> 00:28:14,840
，只要它没有暂停，它就会一直这样做
。

657
00:28:14,840 --> 00:28:17,220
如果它被暂停，那么你
只会说，恢复

658
00:28:17,220 --> 00:28:18,270
，它会继续。

659
00:28:19,130 --> 00:28:22,730

这边的督察很厉害。

660
00:28:22,730 --> 00:28:24,638
这不仅仅是改变文本。

661
00:28:24,638 --> 00:28:28,630
您还可以更改
字体、字体颜色等。

662
00:28:28,630 --> 00:28:30,370
在这里，我什至有一些填充。

663
00:28:30,370 --> 00:28:33,640
您会看到这个小蓝点
表示我的填充已打开。

664
00:28:33,640 --> 00:28:35,900
果然，你看到
这里说的是填充，

665
00:28:35,900 --> 00:28:37,950
我们将在这里稍微看一下所有
这些代码，但是这里的

666
00:28:37,950 --> 00:28:42,070
这个小填充
，如果我把它关掉，

667
00:28:42,070 --> 00:28:43,700
它就会把它从那里去掉。

668
00:28:43,700 --> 00:28:47,360
或者，如果我重新打开它但
仅用于垂直填充，

669
00:28:47,360 --> 00:28:49,213
那么我会得到垂直填充。

670
00:28:50,160 --> 00:28:52,380
同样，我们并不担心

671
00:28:52,380 --> 00:28:54,730
这一切意味着什么，但关键

672
00:28:54,730 --> 00:28:56,600
是我们可以在这里改变事物，

673
00:28:56,600 --> 00:28:58,100
它正在改变那里。

674
00:28:59,770 --> 00:29:02,440
这就是你的 Xcode 之旅。

675
00:29:02,440 --> 00:29:04,700
有从底部出现的调试器
。

676
00:29:04,700 --> 00:29:05,910


677
00:29:05,910 --> 00:29:08,220
当我们开始进行一些调试时，我们会看到这一点。

678
00:29:08,220 --> 00:29:10,570


679
00:29:10,570 --> 00:29:12,700
在第一周的讲座中，您不需要使用调试器。

680
00:29:12,700 --> 00:29:14,640
我将
要求你在家庭作业中做的事情

681
00:29:14,640 --> 00:29:17,853
非常简单
，不需要调试。

682
00:29:18,920 --> 00:29:20,150
让我们回去照我说的做

683
00:29:20,150 --> 00:29:24,290
，看看


684
00:29:24,290 --> 00:29:26,680
我们创建这个项目时 Xcode 为我们创建的这四个文件。

685
00:29:26,680 --> 00:29:30,310
我们将从这个开始： Assets.xcassets

686
00:29:30,310 --> 00:29:31,670
当它说资产时，

687
00:29:31,670 --> 00:29:35,330
它表示
图像、声音和视频之类的东西，

688
00:29:35,330 --> 00:29:37,450
这些资产。

689
00:29:37,450 --> 00:29:41,280
当
我们构建一个 iOS 应用程序时，

690
00:29:41,280 --> 00:29:45,840
我们所做的就是将资产拖到
这里并给它们命名。

691
00:29:45,840 --> 00:29:47,350
在白色列中，

692
00:29:47,350 --> 00:29:49,220
这里将是资产的名称

693
00:29:49,220 --> 00:29:52,410
，然后
是实际资产本身。

694
00:29:52,410 --> 00:29:55,820
您将在
此处看到显示的图像。

695
00:29:55,820 --> 00:29:58,230
有些资产比其他资产更
复杂，

696
00:29:58,230 --> 00:30:01,630
例如您的应用程序图标是
一个相当复杂的资产，

697
00:30:01,630 --> 00:30:05,090
因为它有很多
不同的分辨率。

698
00:30:05,090 --> 00:30:08,900
这里的这些分辨率
取决于环境，

699
00:30:08,900 --> 00:30:10,780
无论是在 iPad 或 iPhone 上，

700
00:30:10,780 --> 00:30:12,613
还是您在聚光灯下，

701
00:30:12,613 --> 00:30:14,770
是否表示

702
00:30:14,770 --> 00:30:17,320
您的 iPhone 上刚刚收到该应用程序的通知等。

703
00:30:17,320 --> 00:30:18,730
如果您有一个应用程序，

704
00:30:18,730 --> 00:30:21,210
尤其是 一个你要
发送到应用商店的应用程序，

705
00:30:21,210 --> 00:30:24,930
你可能会
请一位艺术家或其他人

706
00:30:24,930 --> 00:30:27,060
制作一些

707
00:30:27,060 --> 00:30:29,653
在所有这些分辨率下看起来都不错的完美图标
。

708
00:30:30,590 --> 00:30:32,670
我们不会
更多地查看这些资产，

709
00:30:32,670 --> 00:30:35,620
但是稍后
当我们想要将图像添加

710
00:30:35,620 --> 00:30:38,709
到我们的应用程序时，我们将使用它。

711
00:30:38,709 --> 00:30:41,850
这个东西怎么样，Info.plist？

712
00:30:41,850 --> 00:30:45,800
这本质上
是您的应用程序的设置，

713
00:30:45,800 --> 00:30:48,410
但这是一种非常原始的编辑方式

714
00:30:48,410 --> 00:30:52,240
，我们通常不会
直接编辑此 Info.plist。

715
00:30:52,240 --> 00:30:54,600
相反，如果我们进入我们的项目

716
00:30:54,600 --> 00:30:56,700
并单击项目本身，

717
00:30:56,700 --> 00:31:01,700
我们会得到一个很好的 UI 来编辑
这些相同的设置。

718
00:31:02,550 --> 00:31:04,190
我们在谈论什么样的
设置？

719
00:31:04,190 --> 00:31:06,790
那么，这个应用程序可以在 iPhone 上运行吗？

720
00:31:06,790 --> 00:31:07,623
是的。

721
00:31:07,623 --> 00:31:09,358
iPad？ 是的。 它可以在 Mac 上运行吗？

722
00:31:09,358 --> 00:31:10,191
不，

723
00:31:10,191 --> 00:31:13,440
我们不会构建这个
Memorize 应用程序来在 Mac 上运行。

724
00:31:13,440 --> 00:31:16,460
我们要做的下一个应用程序，我们
将让它在 Mac 上运行。

725
00:31:16,460 --> 00:31:20,980
另外，我们是否部署到
iOS 14、iOS 13、iOS 11？

726
00:31:20,980 --> 00:31:24,230
我们
尝试部署的越远，

727
00:31:24,230 --> 00:31:27,070
我们使用的新功能就越少。

728
00:31:27,070 --> 00:31:29,497
所有这些东西，当
你

729
00:31:29,497 --> 00:31:32,170
在这个漂亮的 UI 开关中改变它们时，

730
00:31:32,170 --> 00:31:35,600
它也会在这个
列表中改变它。

731
00:31:35,600 --> 00:31:38,530
我们根本不看我们的
Info.plist。

732
00:31:38,530 --> 00:31:40,260


733
00:31:40,260 --> 00:31:43,770
如果我们想更改项目
设置，我们几乎总是点击此处，并且 99% 的时间，

734
00:31:43,770 --> 00:31:46,030
您不需要更改
任何这些设置。

735
00:31:46,030 --> 00:31:48,723
他们只是默认正确的事情。

736
00:31:50,100 --> 00:31:53,410
这给我们留下了这
两个文件。

737
00:31:53,410 --> 00:31:57,180
它们都是 .swift 文件，
Swift 语言文件。

738
00:31:57,180 --> 00:31:59,120
Swift 是一种新语言

739
00:31:59,120 --> 00:32:02,420
，我将
从头开始向您展示。

740
00:32:02,420 --> 00:32:05,060
这个就在这里，MemorizeApp.swift，

741
00:32:05,060 --> 00:32:07,310
我不会
太仔细地看那个。

742
00:32:07,310 --> 00:32:09,670
真的没有太大关系。

743
00:32:09,670 --> 00:32:11,550
有几点需要注意，

744
00:32:11,550 --> 00:32:16,370
它是我们的主程序。
在 C 中，您有 main.c

745
00:32:16,370 --> 00:32:19,130
，它是您的应用程序

746
00:32:19,130 --> 00:32:20,363
运行时开始执行的主要 C 模块。

747
00:32:20,363 --> 00:32:23,010
我们在 Swift 中也有同样的东西
，就是这样。

748
00:32:23,010 --> 00:32:25,100
因为我们把这个@main 放在这里，所以

749
00:32:25,100 --> 00:32:27,200
这成为我们的主程序。

750
00:32:27,200 --> 00:32:29,230
我们对这一切都不太担心。

751
00:32:29,230 --> 00:32:31,530
这里要注意的主要

752
00:32:31,530 --> 00:32:34,610
一点是，中间的这个 ContentView()
基本上是

753
00:32:34,610 --> 00:32:37,450
说另一个 Swift
文件 ContentView.swift

754
00:32:37,450 --> 00:32:40,830
是描述
我们应用程序外观的东西。

755
00:32:40,830 --> 00:32:43,549
当我们在这里的模拟器

756
00:32:43,549 --> 00:32:47,910
看到我们的应用程序时，无论我们谈论的是哪个应用程序，这里的
整个区域

757
00:32:47,910 --> 00:32:51,070

都是

758
00:32:51,070 --> 00:32:53,930
我们的 ContentView.swift。

759
00:32:53,930 --> 00:32:56,140
这就是
主程序所说的所有

760
00:32:56,140 --> 00:32:59,350
内容，那个主区域的名称是什么？

761
00:32:59,350 --> 00:33:01,330
就是这样，ContentView.swift，

762
00:33:01,330 --> 00:33:05,720
所以这段代码就是制作它的
全部代码。

763
00:33:05,720 --> 00:33:07,490
事实上，它

764
00:33:07,490 --> 00:33:09,070
比整个代码多一点。

765
00:33:09,070 --> 00:33:11,400
在 ContentView_Previews 底部也有这个小
东西

766
00:33:11,400 --> 00:33:13,470
。

767
00:33:13,470 --> 00:33:17,360
这是将此预览器粘合

768
00:33:17,360 --> 00:33:19,420
到我们的 ContentView 的代码。

769
00:33:19,420 --> 00:33:22,830
所以真的只有这


770
00:33:22,830 --> 00:33:24,857
就是绘制我们的“你好，世界！”的全部代码。

771
00:33:24,857 --> 00:33:29,340
而这个胶水代码，我们
几乎没有碰过它。

772
00:33:29,340 --> 00:33:32,150
我将
在本周讲座的稍后部分向您展示，

773
00:33:32,150 --> 00:33:33,850
我们如何对其进行一些修改，

774
00:33:33,850 --> 00:33:36,150
但大多数时候我们都
没有注意。 事实上，

775
00:33:36,150 --> 00:33:37,380
我通常喜欢把它

776
00:33:37,380 --> 00:33:39,527
拿开，
所以我什至看不到它。

777
00:33:39,527 --> 00:33:41,970
它在下面。 它正在做胶水，

778
00:33:41,970 --> 00:33:43,780
但我什至不看它。

779
00:33:43,780 --> 00:33:46,540
请注意，顺便说一句，当
我做出这样的重大更改时，

780
00:33:46,540 --> 00:33:50,963
我们的预览器暂停了，所以我可以
点击恢复，它会继续。

781
00:33:52,600 --> 00:33:53,533
好的，就是这样。

782
00:33:53,533 --> 00:33:56,060
这就是你的 Xcode 之旅。

783
00:33:56,060 --> 00:33:59,980
现在我们将专注
于这些代码行，

784
00:33:59,980 --> 00:34:03,250
并了解
这里的每一行代码的作用。

785
00:34:03,250 --> 00:34:04,450
我要重置这个

786
00:34:04,450 --> 00:34:08,220
“你好，cs193p！” “你好，世界！”

787
00:34:08,220 --> 00:34:09,786
让我们把它隐藏起来，然后把注意力集中在

788
00:34:09,786 --> 00:34:12,850
那个 ContentView

789
00:34:12,850 --> 00:34:15,382
上，一点点不碍事。

790
00:34:15,382 --> 00:34:16,870
让我们逐行浏览。

791
00:34:16,870 --> 00:34:19,810
最重要的是：导入 SwiftUI。

792
00:34:19,810 --> 00:34:21,080
这个很容易。

793
00:34:21,080 --> 00:34:24,670

这就像其他语言的包含或导入。

794
00:34:24,670 --> 00:34:26,790
我们基本上只是说这个

795
00:34:26,790 --> 00:34:31,170
文件将使用
名为 SwiftUI 的包 Swift 代码。

796
00:34:31,170 --> 00:34:36,170
这是由 Apple 制造的，它
随所有 iOS 设备

797
00:34:36,350 --> 00:34:39,340
、Mac OS 和 Apple
Watch 以及所有这些东西一起提供。

798
00:34:39,340 --> 00:34:43,630
它在这里是因为我们
在这个文件中做 UI，

799
00:34:43,630 --> 00:34:47,390
但并不是我们
创建的每个文件都会有 UI。

800
00:34:47,390 --> 00:34:49,640
例如，我们创建的文件

801
00:34:49,640 --> 00:34:51,380
执行我们的游戏逻辑

802
00:34:51,380 --> 00:34:54,480
，实际匹配卡片并记录分数，

803
00:34:54,480 --> 00:34:57,020
而不是 UI。 这是逻辑

804
00:34:57,020 --> 00:34:58,750
，不会导入 SwiftUI。

805
00:34:58,750 --> 00:35:01,050
SwiftUI 的一大优点

806
00:35:01,050 --> 00:35:05,320
是它如何清楚地
将逻辑与 UI 分开。

807
00:35:05,320 --> 00:35:06,740
但在这里，我们正在处理 UI。

808
00:35:06,740 --> 00:35:09,100
我们甚至要到下周才
开始做我们的游戏逻辑

809
00:35:09,100 --> 00:35:11,060
，所以这就是所有的 UI，

810
00:35:11,060 --> 00:35:13,863
所以我们当然
要在这里导入 SwiftUI。

811
00:35:16,230 --> 00:35:21,090
这是我们
生成 UI 的全部代码

812
00:35:21,090 --> 00:35:23,890
，它在这里创建了一个数据结构。

813
00:35:23,890 --> 00:35:27,600
所以struct是data structure的简称

814
00:35:27,600 --> 00:35:29,818
，大部分语言都有struct。

815
00:35:29,818 --> 00:35:33,810
结构本质上
是变量的集合

816
00:35:33,810 --> 00:35:37,750
，C 和
几乎所有的语言都有这个，

817
00:35:37,750 --> 00:35:39,900
它们可能不称它为
结构，但它们有

818
00:35:39,900 --> 00:35:42,203
某种变量的集合。

819
00:35:43,360 --> 00:35:46,760
Swift 的
变量集合非常强大，

820
00:35:46,760 --> 00:35:50,440
因为我们不仅可以
在我们的

821
00:35:50,440 --> 00:35:52,530
结构体中拥有变量，
事实上，这是

822
00:35:52,530 --> 00:35:53,971
我们稍后会看到的变量，

823
00:35:53,971 --> 00:35:55,620
而且我们还可以拥有函数。

824
00:35:55,620 --> 00:35:59,490
所以，func foo，里面有一些代码，

825
00:35:59,490 --> 00:36:01,120
这是完全合法的。

826
00:36:01,120 --> 00:36:04,630
我们将在
下周特别关注函数，

827
00:36:04,630 --> 00:36:06,200
但事实证明，我们实际上并不需要太多

828
00:36:06,200 --> 00:36:08,850
的函数来
构建这个 UI，

829
00:36:08,850 --> 00:36:11,580
但结构体上可以有函数。

830
00:36:11,580 --> 00:36:14,900
很多人可能觉得这喜欢

831
00:36:14,900 --> 00:36:17,026
面向对象的编程，

832
00:36:17,026 --> 00:36:19,360
因为面向对象的编程是

833
00:36:19,360 --> 00:36:24,000
一些数据变量
与

834
00:36:24,000 --> 00:36:25,460
它的功能封装在一起。

835
00:36:25,460 --> 00:36:29,150
我们在
面向对象编程中称为方法。

836
00:36:29,150 --> 00:36:32,150
而且 Swift 确实支持

837
00:36:32,150 --> 00:36:33,640
面向对象的编程

838
00:36:33,640 --> 00:36:36,460
，我们甚至会使用
面向对象的编程，

839
00:36:36,460 --> 00:36:38,977
特别是将我们的逻辑连接到我们的 UI。

840
00:36:38,977 --> 00:36:40,990
下周你会看到的。

841
00:36:40,990 --> 00:36:43,246
但是，您本周所看到的都不

842
00:36:43,246 --> 00:36:45,730
是面向对象的编程。

843
00:36:45,730 --> 00:36:47,930
特别是结构，即使

844
00:36:47,930 --> 00:36:51,550
它们可以有变量和
函数，也不

845
00:36:51,550 --> 00:36:54,860
是面向对象的东西。
他们不是班级。

846
00:36:54,860 --> 00:36:58,210
没有继承
或类似的

847
00:36:58,210 --> 00:37:00,430
东西，结构有不同的东西

848
00:37:00,430 --> 00:37:02,090
，我正要谈论，

849
00:37:02,090 --> 00:37:05,210
这导致了
一种我们称之为

850
00:37:05,210 --> 00:37:07,130
函数式编程的编程。

851
00:37:07,130 --> 00:37:09,560
Swift 支持
面向对象编程

852
00:37:09,560 --> 00:37:10,810
和函数式编程。

853
00:37:10,810 --> 00:37:14,220
我们


854
00:37:14,220 --> 00:37:16,320
在我们构建的 UI 代码中使用了函数式编程设计模型。

855
00:37:16,320 --> 00:37:20,370
我们使用面向对象的
设计模型将

856
00:37:20,370 --> 00:37:24,710
我们的模型、我们的逻辑类型连接到我们的 UI。

857
00:37:24,710 --> 00:37:27,670
今天
我们谈论的所有事情都是

858
00:37:27,670 --> 00:37:30,040
函数式编程。

859
00:37:30,040 --> 00:37:31,897
好吧，我们显然
不需要这个函数 foo，

860
00:37:31,897 --> 00:37:33,920
反正什么也不做。

861
00:37:33,920 --> 00:37:35,570
struct 之后的下一步是什么？

862
00:37:35,570 --> 00:37:37,860
结构是一个关键字。
我们所有的关键词，当然，

863
00:37:37,860 --> 00:37:41,480
这里都是洋红色的，很容易理解。

864
00:37:41,480 --> 00:37:43,280
下一个词是 ContentView。

865
00:37:43,280 --> 00:37:46,060
这只是
这个数据结构的名称，

866
00:37:46,060 --> 00:37:47,863
可以是我们想要的任何名称。

867
00:37:49,240 --> 00:37:52,411
这是我们刚刚创建的应用程序，
它说：“Hello，world！”

868
00:37:52,411 --> 00:37:55,250
它并不真正知道我们
要构建一个 Memorize 应用程序，

869
00:37:55,250 --> 00:37:57,010
所以它称这个东西为 ContentView，

870
00:37:57,010 --> 00:38:00,170
因为它本质上
是我们整个应用程序的内容。

871
00:38:00,170 --> 00:38:01,620
我将把它留给它，

872
00:38:01,620 --> 00:38:04,340
但在路上，我们
可能会将它重命名

873
00:38:04,340 --> 00:38:06,570
为类似
MemorizeView 或

874
00:38:06,570 --> 00:38:09,380
更具体的
我们所做的东西，但这只是

875
00:38:09,380 --> 00:38:12,550
这个结构的名称，
没有什么特别之处 .

876
00:38:12,550 --> 00:38:16,323
这很特别。

877
00:38:16,323 --> 00:38:20,030
当
你定义一个结构时，这个小 :View

878
00:38:20,030 --> 00:38:23,290
意味着我们正在创建的这个结构的

879
00:38:23,290 --> 00:38:26,070
行为就像一个视图。

880
00:38:26,070 --> 00:38:28,877
我告诉过你，这是函数式编程

881
00:38:28,877 --> 00:38:31,740
，在函数式编程
中

882
00:38:31,740 --> 00:38:34,500
，事物的行为、事物的行为方式至关重要。

883
00:38:34,500 --> 00:38:36,970
一个事物的大部分行为方式

884
00:38:36,970 --> 00:38:40,390
是您可以调用它的函数

885
00:38:40,390 --> 00:38:42,090
来定义它的行为方式。

886
00:38:42,090 --> 00:38:44,884
但即使是存储、数据存储、

887
00:38:44,884 --> 00:38:47,010
函数式编程，也没有

888
00:38:47,010 --> 00:38:49,410
说明数据的实际存储方式。

889
00:38:49,410 --> 00:38:52,760
它可以稍微讨论一下


890
00:38:52,760 --> 00:38:54,800
这个结构中存在哪些数据以及应该包含哪些数据，

891
00:38:54,800 --> 00:38:56,360
但它没有说明
应该如何存储它，

892
00:38:56,360 --> 00:39:00,310
无论是存储在
内存中还是计算出来的。

893
00:39:00,310 --> 00:39:02,510
这样，它

894
00:39:02,510 --> 00:39:04,040
与面向对象的编程非常不同，
因为您没有用

895
00:39:04,040 --> 00:39:07,220
该存储上的方法封装

896
00:39:07,220 --> 00:39:08,890
存储，即功能。

897
00:39:08,890 --> 00:39:11,190
您只是在
谈论功能

898
00:39:11,190 --> 00:39:14,070
并描述
可能存在的存储。

899
00:39:14,070 --> 00:39:15,903
你实际上并没有实现它。

900
00:39:16,880 --> 00:39:19,810
当你说你有一个
表现

901
00:39:19,810 --> 00:39:22,130
得像某种东西的数据结构时，在这种
情况下表现得像一个视图

902
00:39:22,130 --> 00:39:24,680
，我们稍后会
在这里讨论视图是什么，

903
00:39:24,680 --> 00:39:27,060
这真的是一把双刃剑。

904
00:39:27,060 --> 00:39:30,620
剑的一面
真的很棒，那

905
00:39:30,620 --> 00:39:33,060
就是 View 有很多

906
00:39:33,060 --> 00:39:35,937
内置在 SwiftUI 库中的功能。

907
00:39:35,937 --> 00:39:38,680
只要你说，
你的行为就像一个视图，

908
00:39:38,680 --> 00:39:41,150
你就会得到所有的功能，因为

909
00:39:41,150 --> 00:39:43,810
视图做了所有这些事情
，你的行为就像一个视图，

910
00:39:43,810 --> 00:39:45,040
所以这很棒。

911
00:39:45,040 --> 00:39:47,720
另一方面，剑的另一面


912
00:39:47,720 --> 00:39:50,050
是，


913
00:39:50,050 --> 00:39:51,820
如果你想表现得像一个视图，你可能需要承担一些责任。

914
00:39:51,820 --> 00:39:53,970
你不能只是走
在街上说，是的，

915
00:39:53,970 --> 00:39:55,525
我的行为就像一个视图。

916
00:39:55,525 --> 00:39:58,010
有时表现得像一个视图意味着

917
00:39:58,010 --> 00:39:59,800
你也必须做一些事情。

918
00:39:59,800 --> 00:40:02,680
事实上，表现得像一个视图，尽管

919
00:40:02,680 --> 00:40:05,350
它非常强大，但
实际上只需要

920
00:40:05,350 --> 00:40:09,340
你做一件事，那
就是拥有这个变量。

921
00:40:09,340 --> 00:40:10,520
我们将在稍后查看该变量

922
00:40:10,520 --> 00:40:13,060
及其含义。

923
00:40:13,060 --> 00:40:15,340
但首先让我们谈谈什么是视图。

924
00:40:15,340 --> 00:40:17,680
当我们说
我们正在创建的这个数据结构

925
00:40:17,680 --> 00:40:20,320
表现得像一个视图时，这是什么意思？

926
00:40:20,320 --> 00:40:24,450
好吧，视图只是
屏幕上的一个矩形区域。

927
00:40:24,450 --> 00:40:29,050
这个 struct ContentView
就是这个矩形区域。

928
00:40:29,050 --> 00:40:30,765
这里的角是圆角的，

929
00:40:30,765 --> 00:40:32,800
只是因为设备
正在将它们四舍五入。

930
00:40:32,800 --> 00:40:37,800
这个大矩形区域
就是这个View，ContentView

931
00:40:38,120 --> 00:40:42,090
，一个View有
能力展示里面的东西。

932
00:40:42,090 --> 00:40:44,290
在这里，我们看到它显示了一些文本。

933
00:40:44,290 --> 00:40:45,240
那挺好的。

934
00:40:45,240 --> 00:40:48,050
它还可以

935
00:40:48,050 --> 00:40:50,480
以多点触控事件的形式接收来自用户的输入。

936
00:40:50,480 --> 00:40:53,613
点击、滑动、捏合，诸如此类。

937
00:40:53,613 --> 00:40:56,910
这就是 View 的全部内容，
真的。 它只是

938
00:40:56,910 --> 00:40:59,730

在屏幕上的一个矩形区域中输入和输出的一种方式。

939
00:40:59,730 --> 00:41:03,190
现在这在概念上很简单，
但在实施中

940
00:41:03,190 --> 00:41:06,440
它非常强大，因为
我们想

941
00:41:06,440 --> 00:41:09,270
在屏幕上构建非常漂亮的矩形区域。

942
00:41:09,270 --> 00:41:12,720
例如，
事情正在发生翻天覆地的变化。

943
00:41:12,720 --> 00:41:16,260
在这种视图中，

944
00:41:16,260 --> 00:41:19,320
我们有这个 ContentView
或这个顶级视图，

945
00:41:19,320 --> 00:41:22,130
但这里也有一个视图
，就是这个文本。

946
00:41:22,130 --> 00:41:25,310
这张卡片是一个视图，上面
有很多东西。

947
00:41:25,310 --> 00:41:26,260
它有这个表情符号。

948
00:41:26,260 --> 00:41:29,067
它周围有这种
圆角矩形。

949
00:41:29,067 --> 00:41:31,310
如果我们在这里看一个复杂的东西，

950
00:41:31,310 --> 00:41:32,900
我们会在这里得到各种视图。

951
00:41:32,900 --> 00:41:35,100
那个文本，这个较小的文本，

952
00:41:35,100 --> 00:41:37,320
这个小箭头就在这里，

953
00:41:37,320 --> 00:41:39,930
我们
可以点击某个东西

954
00:41:39,930 --> 00:41:41,370
并转到另一个视图的整个内容。

955
00:41:41,370 --> 00:41:44,870
这些都是视图。
这里的一切，屏幕上的一切，

956
00:41:44,870 --> 00:41:47,400
每个矩形区域都是一个视图。

957
00:41:47,400 --> 00:41:49,750
您可以看到
像这些卡片这样的

958
00:41:49,750 --> 00:41:52,010
一些视图嵌入在较大的视图中。

959
00:41:52,010 --> 00:41:53,527
视图中的视图。

960
00:41:53,527 --> 00:41:55,113
这一点很明显，

961
00:41:55,113 --> 00:41:57,810
几乎每个 UI 系统都有这样的想法

962
00:41:57,810 --> 00:41:59,740
，即屏幕上有矩形区域

963
00:41:59,740 --> 00:42:01,700
，您可以将它们组合起来制作您的 UI。

964
00:42:01,700 --> 00:42:04,870
但是在 Swift 中，我们使用这个

965
00:42:04,870 --> 00:42:06,550
函数式编程模型来实现它，

966
00:42:06,550 --> 00:42:08,513
并且我们说我们正在
构建这个 ContentView

967
00:42:08,513 --> 00:42:10,910
，它的行为就像一个 View。

968
00:42:10,910 --> 00:42:12,440
视图可以做什么？

969
00:42:12,440 --> 00:42:13,340
一大堆东西。

970
00:42:13,340 --> 00:42:16,040
实际上，我们之前
看到了 View 可以做的事情，

971
00:42:16,040 --> 00:42:17,900
那就是它可以被填充。

972
00:42:17,900 --> 00:42:20,560
我们以前在这里有这个文本。

973
00:42:20,560 --> 00:42:22,410
它打开了这个小填充

974
00:42:22,410 --> 00:42:24,060
，它变得更大

975
00:42:24,060 --> 00:42:26,800
了一点，周围有一点空间。
这只是一件小事。

976
00:42:26,800 --> 00:42:28,570
看看这里所有这些其他的东西。

977
00:42:28,570 --> 00:42:30,330
这些都是视图可以做的事情：

978
00:42:30,330 --> 00:42:32,210
设置它们的颜色和所有这些事情。

979
00:42:32,210 --> 00:42:33,150
稍后我们将看到

980
00:42:33,150 --> 00:42:36,368
所有这些以及我们如何
利用

981
00:42:36,368 --> 00:42:39,810
View 行为的力量。

982
00:42:39,810 --> 00:42:43,280
但首先我要
看看 View 的另一面，

983
00:42:43,280 --> 00:42:46,450

即如果我们想要表现

984
00:42:46,450 --> 00:42:49,783
得像一个 View，我们必须
实现这个变量。

985
00:42:50,770 --> 00:42:54,150
这是一个很好的机会
来讨论

986
00:42:54,150 --> 00:42:59,150
结构内部
的变量，Swift 中的数据结构内部的变量。

987
00:42:59,260 --> 00:43:00,750
这就是

988
00:43:00,750 --> 00:43:02,760
声明变量的样子，超级简单。

989
00:43:02,760 --> 00:43:05,020
变量的关键字 var。

990
00:43:05,020 --> 00:43:08,810
body 只是该变量的名称。

991
00:43:08,810 --> 00:43:11,450
然后 :some View，这与

992
00:43:11,450 --> 00:43:12,283
这里的不同。

993
00:43:12,283 --> 00:43:15,760
:some View 是该变量的类型

994
00:43:15,760 --> 00:43:19,240
。 现在，这是一种相当复杂的，

995
00:43:19,240 --> 00:43:21,550
不一定复杂，
但一种重要

996
00:43:21,550 --> 00:43:23,370
的类型。 Tt有点奇怪。

997
00:43:23,370 --> 00:43:25,430
通常，这些类型
将非常简单。

998
00:43:25,430 --> 00:43:28,120
就像 var i 是一个 Int。

999
00:43:28,120 --> 00:43:30,980
或者 var s 是一个字符串。

1000
00:43:30,980 --> 00:43:34,520
这就是 Swift 中大多数变量的
样子。

1001
00:43:34,520 --> 00:43:37,313
这个有一个奇怪的
关键字，里面

1002
00:43:37,313 --> 00:43:39,070
有一些洋红色的关键字。

1003
00:43:39,070 --> 00:43:41,380
此外，它有这个 View 事物

1004
00:43:41,380 --> 00:43:44,290
，我们知道 View
是一种行为事物。

1005
00:43:44,290 --> 00:43:48,320
那么为什么这个body变量的类型，是

1006
00:43:48,320 --> 00:43:51,320
一些View行为的东西呢？

1007
00:43:51,320 --> 00:43:53,540
嗯，这就是它的阅读方式。

1008
00:43:53,540 --> 00:43:58,040
这个主体的类型
就像一个视图。

1009
00:43:58,040 --> 00:44:01,163
这就是这个 var 主体的类型。

1010
00:44:02,550 --> 00:44:03,967
让我们考虑一下。

1011
00:44:03,967 --> 00:44:05,950
这有点奇怪。

1012
00:44:05,950 --> 00:44:09,220
要创建一个
行为类似于 View 的数据结构，

1013
00:44:09,220 --> 00:44:12,160
您需要提供一个变量，

1014
00:44:12,160 --> 00:44:15,323
其类型是其他
行为类似于 View 的东西。

1015
00:44:16,825 --> 00:44:19,160
这有点奇怪。

1016
00:44:19,160 --> 00:44:21,520
这是一个
可能有意义的类比。

1017
00:44:21,520 --> 00:44:24,170
为什么要求表现得像视图

1018
00:44:24,170 --> 00:44:26,120
是你必须有一个变量来

1019
00:44:26,120 --> 00:44:29,120
提供
一些表现得像视图的其他东西。

1020
00:44:29,120 --> 00:44:31,280
这个比喻就是乐高。

1021
00:44:31,280 --> 00:44:33,440
希望你们所有人都


1022
00:44:33,440 --> 00:44:35,530
在生活中玩过乐高积木。

1023
00:44:35,530 --> 00:44:38,570
乐高积木是小积木，
你可以用小积木

1024
00:44:38,570 --> 00:44:41,530
从

1025
00:44:41,530 --> 00:44:44,160
一个小房子里拼出很酷的东西，乐高房子。

1026
00:44:44,160 --> 00:44:48,860
您可以建造乐高
星球大战超级歼星舰

1027
00:44:48,860 --> 00:44:50,350
以及介于两者之间的任何地方。

1028
00:44:50,350 --> 00:44:53,490
所以乐高积木是非常强大的小型拼搭
工具。

1029
00:44:53,490 --> 00:44:56,067
如果你认为
Views 有点像乐高

1030
00:44:56,067 --> 00:44:59,103
，类比，它并不
完美，但它有点工作。

1031
00:44:59,950 --> 00:45:01,370
让我们考虑一下乐高积木。

1032
00:45:01,370 --> 00:45:03,740
假设我想建造一个乐高房子。

1033
00:45:03,740 --> 00:45:05,860
好的，乐高房子里
有所有的房间。

1034
00:45:05,860 --> 00:45:07,900
它有一个厨房。 它有卧室。

1035
00:45:07,900 --> 00:45:09,060
它有浴室。

1036
00:45:09,060 --> 00:45:10,740
假设它有一个餐厅。

1037
00:45:10,740 --> 00:45:12,480
在其中的每一个中，都有

1038
00:45:12,480 --> 00:45:15,200
很多其他的小乐高积木。

1039
00:45:15,200 --> 00:45:16,400
就像，厨房里有

1040
00:45:16,400 --> 00:45:19,827
一堆厨柜、
桌子和电器。

1041
00:45:19,827 --> 00:45:23,340
餐厅有

1042
00:45:23,340 --> 00:45:24,740
餐桌和餐椅。

1043
00:45:24,740 --> 00:45:27,370
你可以看到乐高房子，

1044
00:45:27,370 --> 00:45:29,740
我们实际上是用其他乐高积木建造的。

1045
00:45:29,740 --> 00:45:32,270
我们可以把那个乐高屋想象成

1046
00:45:32,270 --> 00:45:34,520
一千块乐高积木。

1047
00:45:34,520 --> 00:45:37,070
但实际上，当我们
真正建造

1048
00:45:37,070 --> 00:45:39,110
类似乐高房子的东西时，当我们建造

1049
00:45:39,110 --> 00:45:40,450
餐厅时，

1050
00:45:40,450 --> 00:45:44,220
我们
用一些乐高积木搭建小餐桌

1051
00:45:44,220 --> 00:45:47,800
，然后用乐高积木搭建一把
餐厅椅子。

1052
00:45:47,800 --> 00:45:49,760
然后我们将建造
另一张餐厅椅

1053
00:45:49,760 --> 00:45:51,690
和另一张
完全相同的餐厅椅。

1054
00:45:51,690 --> 00:45:54,160
我不知道，我们的餐桌周围可能有
八把餐椅

1055
00:45:54,160 --> 00:45:55,950


1056
00:45:55,950 --> 00:45:57,516
，它们都和

1057
00:45:57,516 --> 00:45:59,520
那些餐椅完全一样。

1058
00:45:59,520 --> 00:46:03,340
因此，如果我们将
餐厅椅子本身视为乐高积木，

1059
00:46:03,340 --> 00:46:05,850
是的，它是一个乐高积木，我们
用其他乐高积木

1060
00:46:05,850 --> 00:46:07,700
将它们堆叠在一起并将它们

1061
00:46:07,700 --> 00:46:10,490
连接起来，
但一旦我们这样做了，

1062
00:46:10,490 --> 00:46:13,750
它本质上就变成了一个乐高积木。
餐厅椅子乐高。

1063
00:46:13,750 --> 00:46:16,100
然后我们可以取其中的八个

1064
00:46:16,100 --> 00:46:18,740
并将它们与
餐桌乐高组合在一起

1065
00:46:18,740 --> 00:46:22,797
，现在我们基本上有
一个餐桌乐高。

1066
00:46:22,797 --> 00:46:24,380
然后也许我们把它

1067
00:46:24,380 --> 00:46:26,440
和
餐厅里的其他家具结合起来，我们就有

1068
00:46:26,440 --> 00:46:30,030
了一个乐高餐厅。 然后
我们把餐厅乐高

1069
00:46:30,030 --> 00:46:31,377
、厨房乐高

1070
00:46:31,377 --> 00:46:33,450
、卧室乐高
和浴室乐高

1071
00:46:33,450 --> 00:46:36,240
放在一起，我们把它们放在一起，
现在我们有了一个房子乐高。

1072
00:46:36,240 --> 00:46:38,600
我们可以把整个巨大的乐高

1073
00:46:38,600 --> 00:46:42,620
房子和其他乐高房子放在一起，
组成一个乐高社区

1074
00:46:42,620 --> 00:46:44,880
和乐高星球，即乐高宇宙。

1075
00:46:44,880 --> 00:46:47,700
我们可以
用乐高构建整个宇宙。

1076
00:46:47,700 --> 00:46:51,620
如果你这样想，你

1077
00:46:51,620 --> 00:46:54,520
可以简单地

1078
00:46:54,520 --> 00:46:58,860
说乐高餐厅
椅子本身就是一个乐高，

1079
00:46:58,860 --> 00:47:01,600
由其他乐高组成，那么
这就是创建视图的方式。

1080
00:47:01,600 --> 00:47:03,580
这就是为什么

1081
00:47:03,580 --> 00:47:05,700
如果你要表现得像一个视图

1082
00:47:05,700 --> 00:47:08,540
，你必须提供


1083
00:47:08,540 --> 00:47:10,757
一个其他视图的主体变量是完全有意义的。

1084
00:47:10,757 --> 00:47:12,510
因为我们将用

1085
00:47:12,510 --> 00:47:15,483
乐高积木搭建乐高积木。
就这么简单。

1086
00:47:16,410 --> 00:47:18,800
为了更好地理解我们的类比
，

1087
00:47:18,800 --> 00:47:22,250
让我们稍微谈谈


1088
00:47:22,250 --> 00:47:24,900
您将在 SwiftUI 中找到的视图类型。

1089
00:47:24,900 --> 00:47:28,580
当然，您会
发现这种视图：文本，

1090
00:47:28,580 --> 00:47:30,670
它就像一块乐高积木，

1091
00:47:30,670 --> 00:47:33,870
一个基本的积木，独立存在。

1092
00:47:33,870 --> 00:47:35,920
如果我们查看我们的 UI，它们无处不在。

1093
00:47:35,920 --> 00:47:38,930
这里和这里和这里。 在卡片上，

1094
00:47:38,930 --> 00:47:42,260
这个表情符号只是一个
字符串，一个小文本。

1095
00:47:42,260 --> 00:47:45,100
所以这是一种清晰的视图。

1096
00:47:45,100 --> 00:47:47,360
同样，我们有

1097
00:47:47,360 --> 00:47:52,100
圆角矩形、圆形
和椭圆形之类的

1098
00:47:52,100 --> 00:47:55,683
形状，诸如此类的基本形状，它们
也是乐高积木。

1099
00:47:56,840 --> 00:47:59,010
但

1100
00:47:59,010 --> 00:48:00,700
我们将在 SwiftUI 中找到的真正强大的视图

1101
00:48:00,700 --> 00:48:03,580
是组合器，即乐高组合器。

1102
00:48:03,580 --> 00:48:06,100
它们是
采用这些其他视图

1103
00:48:06,100 --> 00:48:07,830
并将它们组合在屏幕上的东西。

1104
00:48:07,830 --> 00:48:11,140
要么把它们排列成一个
网格，也许像这样，

1105
00:48:11,140 --> 00:48:13,130
或者也许只是在一条线上，

1106
00:48:13,130 --> 00:48:16,670
把它们堆叠
在一起，像这样。

1107
00:48:16,670 --> 00:48:18,810
这些组合视图

1108
00:48:18,810 --> 00:48:21,070
可能是


1109
00:48:21,070 --> 00:48:23,330
在这个

1110
00:48:23,330 --> 00:48:26,510
乐高拼凑模型中制作复杂用户界面的最重要的东西。

1111
00:48:26,510 --> 00:48:28,340


1112
00:48:28,340 --> 00:48:31,350
我将要
讨论另一种视图，就像

1113
00:48:31,350 --> 00:48:35,950
如果你想用我们的乐高
类比，它是一袋乐高。

1114
00:48:35,950 --> 00:48:38,340
如果您购买包含数千件的非常大的乐高积木

1115
00:48:38,340 --> 00:48:40,810
，比如说，

1116
00:48:40,810 --> 00:48:43,570
星球大战千年隼之类的。

1117
00:48:43,570 --> 00:48:45,040
当你打开盒子时，

1118
00:48:45,040 --> 00:48:47,880
乐高的人
非常友好地

1119
00:48:47,880 --> 00:48:49,530
把这几千块中的很多块

1120
00:48:49,530 --> 00:48:52,490
装进了透明的小
塑料袋里，这样当你看到

1121
00:48:52,490 --> 00:48:55,000

千年隼的部分时，比如说

1122
00:48:55,000 --> 00:48:57,350
底部的炮塔或 一些东西，

1123
00:48:57,350 --> 00:48:59,490
你不必
搜索成千上万

1124
00:48:59,490 --> 00:49:01,150
的部分来找到构建它的部分。

1125
00:49:01,150 --> 00:49:03,410
有一个袋子。 有炮塔包

1126
00:49:03,410 --> 00:49:05,180
，你打开它，
里面只有几百

1127
00:49:05,180 --> 00:49:08,140

块来建造那个部分。

1128
00:49:08,140 --> 00:49:10,800
因此，您不会


1129
00:49:10,800 --> 00:49:12,630
通过将袋子放在上面

1130
00:49:12,630 --> 00:49:15,730
或将袋子粘在
某个地方来构建您的乐高千年隼。 您打开袋子

1131
00:49:15,730 --> 00:49:17,650
并组合乐高积木。

1132
00:49:17,650 --> 00:49:20,300
所以，
我谈到的最后两种视图

1133
00:49:20,300 --> 00:49:23,540
，组合器和
乐高的包，它们一起出现。

1134
00:49:23,540 --> 00:49:25,480
组合器显然会

1135
00:49:25,480 --> 00:49:29,333
拿一袋乐高积木并
打开并将其组合在一起。

1136
00:49:31,840 --> 00:49:34,860
有了
对不同类型视图的了解，

1137
00:49:34,860 --> 00:49:37,510
您将看到这个 var

1138
00:49:37,510 --> 00:49:41,520
主体几乎总是
会成为组合视图。

1139
00:49:41,520 --> 00:49:45,130
在我们的例子中，现在，它
只是一个乐高积木，

1140
00:49:45,130 --> 00:49:49,380
这个文本，但是这个一些
视图将是一个视图

1141
00:49:49,380 --> 00:49:50,670
，

1142
00:49:50,670 --> 00:49:53,070
大部分时间，
绝大多数时间都是组合视图。

1143
00:49:53,986 --> 00:49:57,300
我们稍后会回到一些 View 语法

1144
00:49:57,300 --> 00:49:59,210
以及它的真正含义。

1145
00:49:59,210 --> 00:50:00,340
但首先我想在这里谈谈

1146
00:50:00,340 --> 00:50:02,680
这段小代码。

1147
00:50:02,680 --> 00:50:04,550
这是什么？

1148
00:50:04,550 --> 00:50:06,860
它只是

1149
00:50:06,860 --> 00:50:10,160
在这个 var 主体之后突然出现在这里：一些视图。

1150
00:50:10,160 --> 00:50:14,500
这实际上是一个函数，我告诉过

1151
00:50:14,500 --> 00:50:17,190
你 Swift 是一种函数式
编程语言。

1152
00:50:17,190 --> 00:50:19,820
在函数式编程
语言中，函数

1153
00:50:19,820 --> 00:50:21,220
非常非常重要。

1154
00:50:21,220 --> 00:50:24,010
事实上，函数是
一等公民

1155
00:50:24,010 --> 00:50:26,720
，我们可以
随心所欲地丢弃函数。

1156
00:50:26,720 --> 00:50:29,300
这对你们中的一些人来说，

1157
00:50:29,300 --> 00:50:32,399
甚至是编程 Java
或类似的语言，

1158
00:50:32,399 --> 00:50:36,130
将函数


1159
00:50:36,130 --> 00:50:39,050
放在
代码中间可能会有点不和谐，

1160
00:50:39,050 --> 00:50:40,410
但你会想要习惯它，

1161
00:50:40,410 --> 00:50:42,400
因为 在函数式
编程语言中，

1162
00:50:42,400 --> 00:50:44,500
函数无处不在。

1163
00:50:44,500 --> 00:50:46,220
它们无处不在。

1164
00:50:46,220 --> 00:50:49,920
这个函数恰好
在这里没有参数

1165
00:50:49,920 --> 00:50:52,210
，也没有名字。 它不需要名称，

1166
00:50:52,210 --> 00:50:54,870
因为我只是将其
直接放入代码中。

1167
00:50:54,870 --> 00:50:57,310
这个函数实际上返回了一些东西。

1168
00:50:57,310 --> 00:51:00,957
它返回一个文本，这个文本。

1169
00:51:00,957 --> 00:51:03,730
你可能会说，“好吧，
return 语句在哪里？”

1170
00:51:03,730 --> 00:51:06,080
那里确实有一个退货
声明。

1171
00:51:06,080 --> 00:51:09,220
这是一种隐藏的退货
声明。

1172
00:51:09,220 --> 00:51:10,520


1173
00:51:10,520 --> 00:51:14,340
如果我在 Command-B
下构建顺便说一句，

1174
00:51:14,340 --> 00:51:16,380
它会说“构建成功”，我会把它留在那里。

1175
00:51:16,380 --> 00:51:18,100
这个回报确实属于那里，

1176
00:51:18,100 --> 00:51:20,290
它只是被 Swift 隐藏，

1177
00:51:20,290 --> 00:51:23,288
只是为了让世界
看起来更美好一点。

1178
00:51:23,288 --> 00:51:25,750
我们会看到
很多 Swift

1179
00:51:25,750 --> 00:51:29,590
隐藏无关关键字和事情的例子，

1180
00:51:29,590 --> 00:51:32,698
当它很明显
发生了什么的时候。

1181
00:51:32,698 --> 00:51:35,150
它一直这样做是为了让我们的代码

1182
00:51:35,150 --> 00:51:36,453
看起来更好一点。

1183
00:51:37,530 --> 00:51:40,050
这是一个没有
名字的函数，没有参数。

1184
00:51:40,050 --> 00:51:42,710
在这种情况下，它返回一个文本。

1185
00:51:42,710 --> 00:51:44,490
那么它在那里做什么呢？

1186
00:51:44,490 --> 00:51:46,530
这个函数

1187
00:51:46,530 --> 00:51:49,500
在代码中间
，在这个 var 主体之后是什么？

1188
00:51:49,500 --> 00:51:53,610
此 var 主体实际上并未
存储在内存中。

1189
00:51:53,610 --> 00:51:55,720
它不是存储在内存中的变量。

1190
00:51:55,720 --> 00:51:58,520
它实际上是一个

1191
00:51:58,520 --> 00:52:00,510
通过执行这个函数计算出来的变量。

1192
00:52:00,510 --> 00:52:04,100
每次有人问这个
ContentView 结构时，“嘿，

1193
00:52:04,100 --> 00:52:07,270
你的
变量 body 的值是多少？”

1194
00:52:07,270 --> 00:52:11,290
它执行这个函数并
返回它返回的任何东西。

1195
00:52:11,290 --> 00:52:12,681
在这种情况下，它将返回

1196
00:52:12,681 --> 00:52:14,723
这个乐高积木，这个文本。

1197
00:52:14,723 --> 00:52:16,900
文字，什么是文字？

1198
00:52:16,900 --> 00:52:21,150
文本是另一种结构
，其行为类似于视图，

1199
00:52:21,150 --> 00:52:23,740
即我所说的乐高积木，
因此必须如此。

1200
00:52:23,740 --> 00:52:25,373
换句话说，在 SwiftUI 的某个地方，

1201
00:52:25,373 --> 00:52:27,800
有一些东西是 struct Text。

1202
00:52:27,800 --> 00:52:31,000
它的行为就像一个视图，
它可能有一个 var 主体。

1203
00:52:31,000 --> 00:52:33,710
这是一些视图，里面有

1204
00:52:33,710 --> 00:52:35,460
一些代码。

1205
00:52:35,460 --> 00:52:36,440


1206
00:52:36,440 --> 00:52:38,310
在 Swift 的某个地方可能有一些类似这样的代码。

1207
00:52:38,310 --> 00:52:41,040
也许不完全是那样，
但就是那样。

1208
00:52:41,040 --> 00:52:42,780
所以，这本身

1209
00:52:42,780 --> 00:52:44,920
就是一个表现得像视图的东西。

1210
00:52:44,920 --> 00:52:46,700
这里有一个函数，
它返回

1211
00:52:46,700 --> 00:52:48,080
的行为类似于 View

1212
00:52:48,080 --> 00:52:51,450
，这很好，因为这个 var

1213
00:52:51,450 --> 00:52:55,940
主体应该是某种 View 的类型


1214
00:52:55,940 --> 00:52:57,940
，行为类似于 View 的东西。

1215
00:52:57,940 --> 00:53:01,370
所以这些匹配。 此
函数返回

1216
00:53:01,370 --> 00:53:03,307
与此变量类型匹配的内容。

1217
00:53:03,307 --> 00:53:06,150
当然，如果您要


1218
00:53:06,150 --> 00:53:09,497
通过
在其中插入一个函数

1219
00:53:09,497 --> 00:53:12,640
并执行它来设置变量的值，
则类型更好地匹配，

1220
00:53:12,640 --> 00:53:15,560
无论返回什么，都
更好地匹配这个。

1221
00:53:15,560 --> 00:53:17,730
在这种情况下确实如此。 这很棒。

1222
00:53:17,730 --> 00:53:19,660
事实上，这
将帮助我们

1223
00:53:19,660 --> 00:53:23,200
理解一些 View

1224
00:53:23,200 --> 00:53:26,470
在我们的编译器编译这段代码时真正变成了什么。

1225
00:53:26,470 --> 00:53:30,660
一些视图，它
本身并不是一种类型。

1226
00:53:30,660 --> 00:53:32,030
这更像是

1227
00:53:32,030 --> 00:53:35,060
给编译器的一些建议，“嘿，

1228
00:53:35,060 --> 00:53:38,270
这个变量的类型
将是一些视图。

1229
00:53:38,270 --> 00:53:40,590
请弄清楚它实际上是什么，

1230
00:53:40,590 --> 00:53:43,600
并
在编译时用它替换它。”

1231
00:53:43,600 --> 00:53:45,690
在这种情况下，
编译器将

1232
00:53:45,690 --> 00:53:48,350
查看这个函数，
看到它返回了一个 Text

1233
00:53:48,350 --> 00:53:50,210
并且它将本质上

1234
00:53:50,210 --> 00:53:53,260
用 Text 替换它，因为那是它的类型。

1235
00:53:53,260 --> 00:53:56,440
再一次，如果我编译，成功！

1236
00:53:56,440 --> 00:54:01,020
因为这个 var body 的类型是 Text。

1237
00:54:01,020 --> 00:54:04,060
它有一个函数，返回一个文本。

1238
00:54:04,060 --> 00:54:07,430
为什么我们不直接说 var body: Text

1239
00:54:07,430 --> 00:54:08,620
从一开始？

1240
00:54:08,620 --> 00:54:12,555
为什么我们做了一些奇怪的视图？

1241
00:54:12,555 --> 00:54:14,370
确实有两个原因。

1242
00:54:14,370 --> 00:54:18,520
一，当我们
试图表现得像一个视图时，

1243
00:54:18,520 --> 00:54:20,800
这个视图必须
说明你必须做什么

1244
00:54:20,800 --> 00:54:22,140
才能表现得像一个视图。

1245
00:54:22,140 --> 00:54:23,420
所以它不会说，

1246
00:54:23,420 --> 00:54:25,780
“哦，你必须
提供一个文本的 var 主体。”

1247
00:54:25,780 --> 00:54:27,917
因为当然你
可以表现得像一个 View

1248
00:54:27,917 --> 00:54:32,230
并且你的 var body 可以
是一些组合视图

1249
00:54:32,230 --> 00:54:35,550
，在这里完成整个 UI。

1250
00:54:35,550 --> 00:54:38,470
此处的整个 UI

1251
00:54:38,470 --> 00:54:41,350
由
该版本应用程序的 ContentView 返回。

1252
00:54:41,350 --> 00:54:44,340
部分只是声明，

1253
00:54:44,340 --> 00:54:46,580
只是声明正在发生的事情。

1254
00:54:46,580 --> 00:54:48,020
但另一部分是，

1255
00:54:48,020 --> 00:54:49,680
我们要让这里的代码

1256
00:54:49,680 --> 00:54:51,210
变得越来越复杂。

1257
00:54:51,210 --> 00:54:53,310
它从一块乐高积木开始，

1258
00:54:53,310 --> 00:54:55,890
最终成为一个完整的游戏应用程序。

1259
00:54:55,890 --> 00:54:58,030
然后随着它变得
越来越复杂

1260
00:54:58,030 --> 00:55:00,390
，这个返回的东西的类型

1261
00:55:00,390 --> 00:55:02,890
显然会
变得更加复杂

1262
00:55:02,890 --> 00:55:04,970
，我们不想

1263
00:55:04,970 --> 00:55:07,260
弄清楚它到底是什么，或者输入它。

1264
00:55:07,260 --> 00:55:09,470
我们希望
编译器为我们解决这个问题。

1265
00:55:09,470 --> 00:55:11,000
这就是编译器擅长

1266
00:55:11,000 --> 00:55:12,823
查看代码并

1267
00:55:12,823 --> 00:55:14,213
找出事物类型的原因。

1268
00:55:14,213 --> 00:55:16,261
它非常非常擅长这一点。

1269
00:55:16,261 --> 00:55:19,410
我可以通过谈论我们已经看到的东西来非常非常生动地向您展示这

1270
00:55:19,410 --> 00:55:23,891
一点
，即填充。

1271
00:55:23,891 --> 00:55:28,807
我在这里单击了我的文本
。 这已经恢复了

1272
00:55:28,807 --> 00:55:31,450
，我们可以在这里恢复我们的预览，

1273
00:55:31,450 --> 00:55:34,210
恢复，它
显示在预览中

1274
00:55:34,210 --> 00:55:37,880
，并且它还
为我们带回了这个检查员。

1275
00:55:37,880 --> 00:55:40,170
如果你还记得我们最初

1276
00:55:40,170 --> 00:55:41,660
使用这个 Text 开始这整个事情的时候，

1277
00:55:41,660 --> 00:55:44,557
我们会在这里找到这个
padding，然后我们把它关掉了。

1278
00:55:44,557 --> 00:55:46,850
它曾经是一个小蓝点

1279
00:55:46,850 --> 00:55:47,967
，我们把它关掉了。

1280
00:55:47,967 --> 00:55:49,210
我要重新打开它。

1281
00:55:49,210 --> 00:55:52,400
所以，现在它的所有面都重新打开了，

1282
00:55:52,400 --> 00:55:54,640
看看那里的填充。

1283
00:55:54,640 --> 00:55:57,290
让我们谈谈


1284
00:55:57,290 --> 00:55:59,420
当我们打开和关闭它时这里发生的事情。

1285
00:55:59,420 --> 00:56:03,500



1286
00:56:03,500 --> 00:56:05,620
当我们重新打开它时，这行代码是什么？

1287
00:56:05,620 --> 00:56:08,240
这可能
更容易理解，

1288
00:56:08,240 --> 00:56:11,670
如果我把它移到同一行

1289
00:56:11,670 --> 00:56:13,153
，你会这样看。

1290
00:56:14,100 --> 00:56:17,120
首先，让我解释一下，这个填充

1291
00:56:17,120 --> 00:56:22,040
只是一个
存在于所有

1292
00:56:22,040 --> 00:56:23,730
表现得像视图的结构中的函数。

1293
00:56:23,730 --> 00:56:27,626
因此，任何
像 ContentView 或 Text 这样的结构，

1294
00:56:27,626 --> 00:56:29,580
任何表现得像 View 的东西，

1295
00:56:29,580 --> 00:56:32,970
它都有一个叫做 padding 的函数。

1296
00:56:32,970 --> 00:56:35,760
这就是你在 Swift 中调用函数的方式。

1297
00:56:35,760 --> 00:56:39,720
您只需找到要在其上

1298
00:56:39,720 --> 00:56:40,810
调用函数的结构。

1299
00:56:40,810 --> 00:56:43,143
如果你在 Swift 中进行面向对象的
编程，

1300
00:56:43,143 --> 00:56:46,430
那么它就是对象，
是类的一个实例。

1301
00:56:46,430 --> 00:56:49,270
然后你就说'。 和名字。

1302
00:56:49,270 --> 00:56:52,320
希望您非常熟悉
，Java 和其他语言以

1303
00:56:52,320 --> 00:56:53,940
完全相同的方式执行此操作，

1304
00:56:53,940 --> 00:56:55,450
然后如果有参数，

1305
00:56:55,450 --> 00:56:57,455
那么您只需在此处提供它们。

1306
00:56:57,455 --> 00:57:01,730
函数的 Swift 参数，
你会

1307
00:57:01,730 --> 00:57:03,560
发现它非常、非常、非常灵活。

1308
00:57:03,560 --> 00:57:06,190
他们可以默认。 你可以
有不同的论点

1309
00:57:06,190 --> 00:57:07,660
，意味着不同的事情。

1310
00:57:07,660 --> 00:57:10,250
例如，在这里，我们有这个 .all

1311
00:57:10,250 --> 00:57:13,100
，我稍后会解释
类似的东西，

1312
00:57:13,100 --> 00:57:15,480
但这意味着所有这些都在这里。

1313
00:57:15,480 --> 00:57:17,700
我们看到，如果我现在单击其中的一些，

1314
00:57:17,700 --> 00:57:21,230
它就是 .horizontal，但它甚至
还有其他内容

1315
00:57:21,230 --> 00:57:23,940
。 我可以在这里输入一个数字，例如 padding(20)。

1316
00:57:23,940 --> 00:57:27,020
这意味着每边放置 20 个填充点


1317
00:57:27,020 --> 00:57:28,200
或填充（100），

1318
00:57:28,200 --> 00:57:30,830
每边放置 100。

1319
00:57:30,830 --> 00:57:35,390
或者没有参数，这意味着
只使用默认填充，

1320
00:57:35,390 --> 00:57:37,370
这是一个非常好的设置，

1321
00:57:37,370 --> 00:57:38,910
因为默认填充


1322
00:57:38,910 --> 00:57:43,080
在 Apple Watch、Apple
TV、MacOS 和 iPad 上可能略有不同。

1323
00:57:43,080 --> 00:57:45,290
所以很多时候我们
喜欢使用默认值

1324
00:57:45,290 --> 00:57:47,880
，因为它们是
特定于平台的。

1325
00:57:47,880 --> 00:57:50,940
但关键是我们可以在参数中放
很多不同的东西

1326
00:57:50,940 --> 00:57:53,300
，而且
它是同一个函数，

1327
00:57:53,300 --> 00:57:55,460
填充，做同样的事情。

1328
00:57:55,460 --> 00:57:57,810
只是你
提供了不同的信息

1329
00:57:57,810 --> 00:57:59,803
来告诉它做什么。

1330
00:58:00,680 --> 00:58:03,750
这个函数，填充，
返回了一些东西。

1331
00:58:03,750 --> 00:58:06,250



1332
00:58:06,250 --> 00:58:09,290
理解这个填充函数
返回一些东西是非常非常重要的。

1333
00:58:09,290 --> 00:58:13,520
它返回的
是行为类似于视图的东西。

1334
00:58:13,520 --> 00:58:16,540
这是与此不同的事情。

1335
00:58:16,540 --> 00:58:20,590
此填充不返回文本。

1336
00:58:20,590 --> 00:58:24,290
它返回一个填充的、修改过的其他视图

1337
00:58:24,290 --> 00:58:26,710
，在这种情况下恰好是一个文本。

1338
00:58:26,710 --> 00:58:29,550
如果我
想在这里输入实际类型，

1339
00:58:29,550 --> 00:58:32,110
我可以去尝试查找
它和文档，

1340
00:58:32,110 --> 00:58:35,450
它可能
类似于 ModifiedContent

1341
00:58:35,450 --> 00:58:39,070
，我不知道。

1342
00:58:39,070 --> 00:58:42,910
有些复杂，
但绝对不是文本。

1343
00:58:42,910 --> 00:58:44,210
事实上，如果我将文本放在这里

1344
00:58:44,210 --> 00:58:46,800
并点击构建，它会显示“构建失败”。

1345
00:58:46,800 --> 00:58:50,440
无法将此
表达式转换为文本类型。

1346
00:58:50,440 --> 00:58:54,100
因为这个表达式不是文本，

1347
00:58:54,100 --> 00:58:58,299
它是任何类型的
View .padding 返回。

1348
00:58:58,299 --> 00:59:01,180

了解这里发生了什么非常重要，

1349
00:59:01,180 --> 00:59:03,210
因为我们
将做很多

1350
00:59:03,210 --> 00:59:05,883
这样的小函数
，它们返回一个新

1351
00:59:05,883 --> 00:59:08,470
视图，一个不同于另一个视图的视图。

1352
00:59:08,470 --> 00:59:10,630
它们被称为视图修饰符，

1353
00:59:10,630 --> 00:59:14,200
因为它们显然
修改了一些其他视图。

1354
00:59:14,200 --> 00:59:16,410
在乐高的世界里，你可以把它想象成，

1355
00:59:16,410 --> 00:59:19,440
我们拿了这块砖，我们把它

1356
00:59:19,440 --> 00:59:22,120
送回工厂，然后说：
“请给我们寄一个新的，

1357
00:59:22,120 --> 00:59:25,200

在它的两边加了一点垫子。”

1358
00:59:25,200 --> 00:59:26,177
基本上就是这样

1359
00:59:26,177 --> 00:59:29,640
，工厂很快
就给我们寄回了一个新的

1360
00:59:29,640 --> 00:59:32,500
，这
就是我们现在在这里使用的砖。

1361
00:59:32,500 --> 00:59:35,165
所以它是一个修改过的文本。

1362
00:59:35,165 --> 00:59:37,770
每次我们在这里做一个修改器，

1363
00:59:37,770 --> 00:59:41,340
它本质上都会
创建一个新的视图。

1364
00:59:41,340 --> 00:59:45,910
这就是为什么拥有一些视图，

1365
00:59:45,910 --> 00:59:49,470
尤其是当它变得
越来越复杂时，

1366
00:59:49,470 --> 00:59:51,928
对我们来说真的很有价值。

1367
00:59:51,928 --> 00:59:55,160

如果我们添加更多的修饰符，我们可以看到更多，

1368
00:59:55,160 --> 00:59:58,310
因为我们当然可以获取这些视图

1369
00:59:58,310 --> 01:00:01,040
并修改它们并再次修改它们。

1370
01:00:01,040 --> 01:00:02,860
例如，让我们在此处获取我们的文本

1371
01:00:02,860 --> 01:00:04,800
并更改其颜色。

1372
01:00:04,800 --> 01:00:07,340
我将

1373
01:00:07,340 --> 01:00:10,140
在我的检查器中选择我的文本，
我只是要改变，

1374
01:00:10,140 --> 01:00:14,453
比方说，字体的颜色
为橙色。

1375
01:00:15,470 --> 01:00:20,080
它
在它和填充之间添加了另一个修饰符。

1376
01:00:20,080 --> 01:00:21,230
让我们看看它是否有效。

1377
01:00:22,880 --> 01:00:24,680
它确实做到了。

1378
01:00:24,680 --> 01:00:27,160
现在，我们实际上在这里进行了
三个视图。

1379
01:00:27,160 --> 01:00:29,060
我们有这个原始视图。

1380
01:00:29,060 --> 01:00:31,990
我们得到了
从这个函数返回的视图，

1381
01:00:31,990 --> 01:00:35,840
它是一个经过修改
使其颜色不同的文本，

1382
01:00:35,840 --> 01:00:38,270
然后我们有一个视图
，它通过获取

1383
01:00:38,270 --> 01:00:41,790
该彩色文本并填充它来返回。

1384
01:00:41,790 --> 01:00:44,410
正是这个视图

1385
01:00:44,410 --> 01:00:46,103
作为某个视图返回。

1386
01:00:47,060 --> 01:00:49,010
你可以看到这里有很大的力量，用这些修改器

1387
01:00:49,010 --> 01:00:51,870
创建我们想要的那种视图

1388
01:00:51,870 --> 01:00:54,160
，
但实际上我们仍然只是

1389
01:00:54,160 --> 01:00:57,510
在谈论拿
一块砖并修改它。

1390
01:00:57,510 --> 01:01:01,280
一块改装的乐高积木
当然很好，

1391
01:01:01,280 --> 01:01:04,380
但我们需要能够组合积木。

1392
01:01:04,380 --> 01:01:07,210
当我们
在这里构建类似这张卡片的东西时，

1393
01:01:07,210 --> 01:01:10,820
它是
这个圆角矩形

1394
01:01:10,820 --> 01:01:15,030
和它上面的一个小表情符号
字符串的组合。

1395
01:01:15,030 --> 01:01:17,890
结合这些，然后将它们结合

1396
01:01:17,890 --> 01:01:20,330
到这个网格中，然后
将它们全部结合到一个大应用程序中，

1397
01:01:20,330 --> 01:01:21,840
这就是我们想要做的。

1398
01:01:21,840 --> 01:01:25,950
让我们在这里专注于
制作一张卡片

1399
01:01:25,950 --> 01:01:30,860
并使用组合视图
将圆角矩形

1400
01:01:30,860 --> 01:01:35,552
与其顶部的文本组合
在一起，这个表情符号文本在顶部。

1401
01:01:35,552 --> 01:01:38,890
为此，我将

1402
01:01:38,890 --> 01:01:41,443
暂时在此处注释掉我的文本。

1403
01:01:42,470 --> 01:01:44,230
所以我在那里输入 Command-/。

1404
01:01:44,230 --> 01:01:46,690
顺便说一句，这是一种快速评论事物

1405
01:01:46,690 --> 01:01:47,680
的好方法。

1406
01:01:47,680 --> 01:01:50,270
你会注意到我遇到了各种各样的错误：

1407
01:01:50,270 --> 01:01:53,570
我的预览无法构建以及所有这些。

1408
01:01:53,570 --> 01:01:56,050
那是因为我注释掉


1409
01:01:56,050 --> 01:01:59,163
了这个函数中唯一
返回某种视图的东西。

1410
01:01:59,163 --> 01:02:00,815
这个 var 主体，

1411
01:02:00,815 --> 01:02:02,687
这个提供这个值的函数，

1412
01:02:02,687 --> 01:02:05,480
必须返回某种视图。

1413
01:02:05,480 --> 01:02:06,313
让我们这样做。

1414
01:02:06,313 --> 01:02:11,190
让我们让它返回一个 RoundedRectangle。

1415
01:02:11,190 --> 01:02:15,220
RoundedRectangle，另一个
内置在 SwiftUI 中的东西，

1416
01:02:15,220 --> 01:02:17,190
它是一块乐高积木。

1417
01:02:17,190 --> 01:02:19,480
请注意，当您键入时，Xcode

1418
01:02:19,480 --> 01:02:22,490
总是跳到那里
试图帮助您。

1419
01:02:22,490 --> 01:02:24,020
在这里，它帮助我解决了

1420
01:02:24,020 --> 01:02:26,000
创建 RoundedRectangle 的所有不同方法

1421
01:02:26,000 --> 01:02:27,380
。

1422
01:02:27,380 --> 01:02:29,810
我可以通过
指定角半径

1423
01:02:29,810 --> 01:02:34,200
甚至确切的大小、
角的宽度和高度来做到这一点。

1424
01:02:34,200 --> 01:02:36,160
我想要这个有圆角半径，

1425
01:02:36,160 --> 01:02:38,900
所以我要点击
这里，果然，它在这里

1426
01:02:38,900 --> 01:02:42,920
填写了一些默认的
圆角半径，25。

1427
01:02:42,920 --> 01:02:45,810
有一个圆角半径的矩形。

1428
01:02:45,810 --> 01:02:47,610
我会点击离开，以便我们可以看到它。

1429
01:02:47,610 --> 01:02:49,070
在那里，看起来不错，

1430
01:02:49,070 --> 01:02:49,903
看起来不错。

1431
01:02:49,903 --> 01:02:51,943
对我来说看起来像一个圆角矩形。

1432
01:02:52,860 --> 01:02:55,410
但是，


1433
01:02:55,410 --> 01:02:58,370
在创建这个矩形的过程
中发生了一件你以前从未见过的奇怪的事情。

1434
01:02:58,370 --> 01:03:00,760
这是我创建的一个矩形。

1435
01:03:00,760 --> 01:03:04,550
查看创建它的参数，这

1436
01:03:04,550 --> 01:03:07,010
与我们使用 Text 的参数甚至是我们使用

1437
01:03:07,010 --> 01:03:10,580
的函数调用
（如 color.orange）非常不同，

1438
01:03:10,580 --> 01:03:13,980
这个参数有一个标签。

1439
01:03:13,980 --> 01:03:18,970
带标签的参数
在 Swift 中很常见。

1440
01:03:18,970 --> 01:03:21,170
它甚至可能

1441
01:03:21,170 --> 01:03:24,660
比没有参数标签更常见。

1442
01:03:24,660 --> 01:03:27,250
这个 Text 没有
像 String

1443
01:03:27,250 --> 01:03:30,900
这样的东西，因为它有点像
它的参数是一些文本，

1444
01:03:30,900 --> 01:03:32,460
所以它有点多余。

1445
01:03:32,460 --> 01:03:37,332
这里也一样。 说
前景色是颜色：橙色，

1446
01:03:37,332 --> 01:03:39,770
这个词颜色太多了。

1447
01:03:39,770 --> 01:03:41,710
顺便说一句，你甚至不需要这个 Color，

1448
01:03:41,710 --> 01:03:43,890
因为 Swift 足够聪明，

1449
01:03:43,890 --> 01:03:45,150
知道你正在传递一种颜色

1450
01:03:45,150 --> 01:03:47,650
，所以你也可以不使用
这个 Color。

1451
01:03:47,650 --> 01:03:49,360
斯威夫特不喜欢你一遍又一遍地
输入同样的东西

1452
01:03:49,360 --> 01:03:51,263
，颜色，颜色，颜色。

1453
01:03:51,263 --> 01:03:54,350
但是在这里，使用 RoundedRectangle，
因为我可以

1454
01:03:54,350 --> 01:03:58,380
通过指定圆角半径
或通过指定大小来创建一个，

1455
01:03:58,380 --> 01:04:01,880
如果我只是说
RoundedRectangle(25.0)，

1456
01:04:01,880 --> 01:04:05,810

那么 25.0 是什么还不够清楚。

1457
01:04:05,810 --> 01:04:09,120
因此，每当您定义自己的函数

1458
01:04:09,120 --> 01:04:11,360
和参数时，

1459
01:04:11,360 --> 01:04:13,020
参数是什么并不明显，

1460
01:04:13,020 --> 01:04:15,280
您想用标签定义它。 下周

1461
01:04:15,280 --> 01:04:17,370
我们将讨论所有
关于函数

1462
01:04:17,370 --> 01:04:20,080
以及我们如何声明它们，
我们如何进行参数，

1463
01:04:20,080 --> 01:04:23,000
我们如何使它们成为可选的，
所有这些业务。

1464
01:04:23,000 --> 01:04:24,630

我们将要看到的一件事是

1465
01:04:24,630 --> 01:04:28,180
我们几乎总是
在我们的论点上贴上标签。

1466
01:04:28,180 --> 01:04:30,190
确实使代码更易于阅读。

1467
01:04:30,190 --> 01:04:32,120

Swift

1468
01:04:32,120 --> 01:04:36,880
从其前身
Objective-C 继承的最好的东西之一就是这些漂亮的标签。

1469
01:04:36,880 --> 01:04:39,003
当然，我可以将其更改
为我想要的任何内容，

1470
01:04:39,003 --> 01:04:41,380
我也可以
在检查器中将其更改为这里。

1471
01:04:41,380 --> 01:04:44,300
我们在那里有 RoundedRectangle。

1472
01:04:44,300 --> 01:04:47,223
RoundedRectangle 只是一个视图。

1473
01:04:47,223 --> 01:04:48,760
它的行为就像一个视图。

1474
01:04:48,760 --> 01:04:50,450
这是一块乐高积木。

1475
01:04:50,450 --> 01:04:52,377
所以我可以做一些事情，比如填充

1476
01:04:52,377 --> 01:04:53,670
并在上面放一些填充。

1477
01:04:53,670 --> 01:04:56,130
也许我只想要水平填充

1478
01:04:56,130 --> 01:04:58,730
，它会做我想做的事。

1479
01:04:58,730 --> 01:05:02,400
使其在
检查器中匹配。 那里一切都很好。

1480
01:05:02,400 --> 01:05:05,770
RoundedRectangle 也是一个 Shape。

1481
01:05:05,770 --> 01:05:08,650
我告诉过你，乐高积木是形状、

1482
01:05:08,650 --> 01:05:11,530
圆形和矩形、圆角矩形
、椭圆形，

1483
01:05:11,530 --> 01:05:14,270
它们都是形状。 Shape 还有一件

1484
01:05:14,270 --> 01:05:16,577
额外的事情可以做，

1485
01:05:16,577 --> 01:05:18,627
那就是

1486
01:05:18,627 --> 01:05:20,890
除了像这样填充 Shape 之外，

1487
01:05:20,890 --> 01:05:23,740
您可以只勾勒出 Shape

1488
01:05:23,740 --> 01:05:27,270
并通过说 .stroke 来做到这一点。

1489
01:05:27,270 --> 01:05:28,780
所以如果我们将 stroke

1490
01:05:28,780 --> 01:05:31,270
放在某个 是一个形状，

1491
01:05:31,270 --> 01:05:33,900
那么它只会做外边缘。

1492
01:05:33,900 --> 01:05:36,420
看外面，只有
外面的边缘，

1493
01:05:36,420 --> 01:05:38,600
这是我们想要的样子，

1494
01:05:38,600 --> 01:05:40,070
无论如何，当牌面朝上时。

1495
01:05:40,070 --> 01:05:42,080
我们希望它在面朝下时被填充，在面朝上时被

1496
01:05:42,080 --> 01:05:45,170
抚摸。

1497
01:05:45,170 --> 01:05:49,280
您也可以进行填充，即填充它，

1498
01:05:49,280 --> 01:05:51,570
但这是默认设置，

1499
01:05:51,570 --> 01:05:53,557
所以这就是我们最初拥有

1500
01:05:53,557 --> 01:05:56,031
它但根本不存在的原因。

1501
01:05:56,031 --> 01:06:00,030
Stroke

1502
01:06:00,030 --> 01:06:01,670
只是一个 Shape 可以理解的函数。

1503
01:06:01,670 --> 01:06:03,117
所以我不能抚摸文本。

1504
01:06:03,117 --> 01:06:06,830
这是因为Text
虽然是View，但不是Shape，

1505
01:06:06,830 --> 01:06:08,550
所以不能被抚摸。

1506
01:06:08,550 --> 01:06:11,420
但是所有
形状的东西也是视图

1507
01:06:11,420 --> 01:06:13,360
，这就是我们可以填充它们的原因。

1508
01:06:13,360 --> 01:06:15,790
笔划也
可以有可选的参数。

1509
01:06:15,790 --> 01:06:18,110
lineWidth: 3

1510
01:06:18,110 --> 01:06:20,260
使这条线有点粗。

1511
01:06:20,260 --> 01:06:22,690
请注意，这也有一个标签。

1512
01:06:22,690 --> 01:06:26,250
因此，这些标签不仅存在
于结构的创建中，

1513
01:06:26,250 --> 01:06:28,760
还存在于调用函数时。

1514
01:06:28,760 --> 01:06:30,260
并非所有人都拥有它。

1515
01:06:30,260 --> 01:06:32,320
Padding 不使用标签

1516
01:06:32,320 --> 01:06:34,910
，正如我们看到的 foregroundColor
不使用标签，

1517
01:06:34,910 --> 01:06:35,830
但其中一些使用标签。

1518
01:06:35,830 --> 01:06:37,030
所以我们将把它留在那里

1519
01:06:37,030 --> 01:06:39,030
只是为了提醒你这可能会发生。

1520
01:06:41,090 --> 01:06:42,910
我们也可以做颜色。

1521
01:06:42,910 --> 01:06:46,930
也许我希望这个
RoundedRectangle 是某种颜色，

1522
01:06:46,930 --> 01:06:49,410
比如我们这里的红色，

1523
01:06:49,410 --> 01:06:51,070
这个红色还在继续。

1524
01:06:51,070 --> 01:06:52,120
那么如何让它变红呢？

1525
01:06:52,120 --> 01:06:54,760
好吧，我会去找我的检查员，

1526
01:06:54,760 --> 01:06:55,900
哦，不。

1527
01:06:55,900 --> 01:06:58,380
在我的检查员中，没有颜色。

1528
01:06:58,380 --> 01:07:01,330
当我检查一个文本时，
它有颜色

1529
01:07:01,330 --> 01:07:02,650
，我刚刚选择了橙色

1530
01:07:02,650 --> 01:07:05,660
，我在这里得到了这个橙色文本。

1531
01:07:05,660 --> 01:07:07,010
但这在这里不存在。

1532
01:07:07,010 --> 01:07:08,300
那我该怎么办？

1533
01:07:08,300 --> 01:07:11,080
好吧，这里出现的是人们想要放在这里

1534
01:07:11,080 --> 01:07:14,640
的最常见的东西
。

1535
01:07:14,640 --> 01:07:17,610
但是
视图可以做的所有事情都可以

1536
01:07:17,610 --> 01:07:19,560
通过这里的搜索字段获得。

1537
01:07:19,560 --> 01:07:21,500
看看哪里写着“添加修饰符”，

1538
01:07:21,500 --> 01:07:23,850
它会让你
添加

1539
01:07:23,850 --> 01:07:26,540
任何你想要的没有出现在这里的修饰符。

1540
01:07:26,540 --> 01:07:28,850
如果我单击此处，您会

1541
01:07:28,850 --> 01:07:32,320
看到 Views 知道如何执行大量修饰符

1542
01:07:32,320 --> 01:07:35,980
。
令人惊讶的是，我们将在本季度末

1543
01:07:35,980 --> 01:07:39,360
涵盖其中的大部分内容
。

1544
01:07:39,360 --> 01:07:43,220
但是，现在，它看起来
有点令人生畏，这么长的名单。

1545
01:07:43,220 --> 01:07:45,140
你会如何找到你想要的？

1546
01:07:45,140 --> 01:07:47,180
好吧，您可以
在这里搜索，只需输入

1547
01:07:47,180 --> 01:07:48,410
例如“颜色”

1548
01:07:48,410 --> 01:07:51,170
，这将向您展示
看起来

1549
01:07:51,170 --> 01:07:55,070
可以修改视图
以执行与颜色相关的七件事。

1550
01:07:55,070 --> 01:07:57,100
就像颜色反转会反转这

1551
01:07:57,100 --> 01:07:59,900
可能会将其从黑色变为白色。

1552
01:07:59,900 --> 01:08:03,220
但我们知道我们想要
这个，前景色。

1553
01:08:03,220 --> 01:08:06,530
当您选择它时，它
实际上确实将其添加

1554
01:08:06,530 --> 01:08:09,300
为此处的部分之一
，前景色。

1555
01:08:09,300 --> 01:08:12,580
我们不要蓝色。 我们希望
它是红色的。

1556
01:08:12,580 --> 01:08:16,633
所以现在我们
有了我们想要的红色边框。

1557
01:08:18,150 --> 01:08:21,180

这里有点混乱

1558
01:08:21,180 --> 01:08:23,610
，因为我们的代码正在

1559
01:08:23,610 --> 01:08:24,760
包装，就像

1560
01:08:24,760 --> 01:08:26,870
在这里的函数调用中间包装一样。

1561
01:08:26,870 --> 01:08:29,840
这就是为什么你
会看到很多次，

1562
01:08:29,840 --> 01:08:31,710
这些东西放在他们自己的线上。

1563
01:08:31,710 --> 01:08:33,510
所以我要把它放在它自己的行上，

1564
01:08:33,510 --> 01:08:35,420
那个放在它自己的行上，

1565
01:08:35,420 --> 01:08:37,370
那个放在它自己的行上，

1566
01:08:37,370 --> 01:08:39,523
这样做很常见。

1567
01:08:41,110 --> 01:08:45,070
我们现在已经非常
擅长使用基本的乐高积木，

1568
01:08:45,070 --> 01:08:47,850
如 RoundedRectangle 或 Text，

1569
01:08:47,850 --> 01:08:51,933
并对其进行修改以使其
看起来符合我们想要的方式。

1570
01:08:53,761 --> 01:08:57,150
如果我们看一下这些卡片，
它只是

1571
01:08:57,150 --> 01:09:00,080
一个 RoundedRectangle 和一些 Text 的组合。

1572
01:09:00,080 --> 01:09:02,973
这些表情符号只是小文本字符串。

1573
01:09:03,820 --> 01:09:06,520
那么我们如何结合这些东西呢？

1574
01:09:06,520 --> 01:09:10,100
好吧，我们想要返回某种视图，

1575
01:09:10,100 --> 01:09:14,660
它是一个组合器，一个视图
组合器，就像我们之前讨论的乐高组合器一样

1576
01:09:14,660 --> 01:09:16,410
。

1577
01:09:16,410 --> 01:09:18,083
所以，这正是我们要做的。

1578
01:09:18,083 --> 01:09:20,190
我们将返回
另一种

1579
01:09:20,190 --> 01:09:22,860
称为 ZStack 的视图。

1580
01:09:22,860 --> 01:09:24,500
稍后我将在这里讨论

1581
01:09:24,500 --> 01:09:26,050
ZStack 的全部内容。

1582
01:09:26,050 --> 01:09:28,853
让我们摆脱我们的 RoundedRectangle。

1583
01:09:29,720 --> 01:09:31,740
当我们尝试创建一个 ZStack 时，

1584
01:09:31,740 --> 01:09:33,448
做我们的小括号，

1585
01:09:33,448 --> 01:09:36,390
Xcode 建议两个不同的版本。

1586
01:09:36,390 --> 01:09:40,570
一个，有一些对齐
参数，然后是内容

1587
01:09:40,570 --> 01:09:43,600
，另一个只是内容。

1588
01:09:43,600 --> 01:09:46,000
我们稍后会讨论这种
对齐方式，

1589
01:09:46,000 --> 01:09:49,840
但 ZStack 的关键
参数是内容。

1590
01:09:50,960 --> 01:09:54,380
所以让我们输入这个内容参数。

1591
01:09:54,380 --> 01:09:57,040
这是这个论点的标签。

1592
01:09:57,040 --> 01:09:58,780
它是什么东西？

1593
01:09:58,780 --> 01:10:01,810
好吧，事实证明它是一个函数。

1594
01:10:01,810 --> 01:10:04,430
是的，函数式编程又来了。

1595
01:10:04,430 --> 01:10:07,670
这是一个函数，
这个函数实际上

1596
01:10:07,670 --> 01:10:10,870
会返回一袋乐高积木。

1597
01:10:10,870 --> 01:10:13,040
记住我们类比中的乐高包，

1598
01:10:13,040 --> 01:10:15,010
当我们建造千年隼号时

1599
01:10:15,010 --> 01:10:17,170
，我们必须给 ZStack 的

1600
01:10:17,170 --> 01:10:19,223
是这个乐高包。

1601
01:10:20,430 --> 01:10:23,770
斯威夫特知道你
会很想制作这些

1602
01:10:23,770 --> 01:10:28,340
乐高包，所以它
让你做起来真的很容易。

1603
01:10:28,340 --> 01:10:32,140
能够创建乐高包确实增强
了功能的概念

1604
01:10:32,140 --> 01:10:34,900
。

1605
01:10:34,900 --> 01:10:37,730
传递

1606
01:10:37,730 --> 01:10:42,205
给 Lego 组合器视图
的这种函数称为视图构建器。

1607
01:10:42,205 --> 01:10:46,870
本质上，它允许您
在此处列出其他视图

1608
01:10:46,870 --> 01:10:49,330
，然后在此处使用此函数将它们打包到一个包中

1609
01:10:49,330 --> 01:10:53,360

并返回它，

1610
01:10:53,360 --> 01:10:57,140
以便 ZStack 将有
一包乐高积木工作。

1611
01:10:57,140 --> 01:10:59,593
我们需要做的就是把

1612
01:10:59,593 --> 01:11:01,660
这些我们已经建在这里

1613
01:11:01,660 --> 01:11:04,010
的东西放在这里。

1614
01:11:04,010 --> 01:11:06,760
我们在这里不需要 return 语句。

1615
01:11:06,760 --> 01:11:08,653
我们可以列出它们。

1616
01:11:10,720 --> 01:11:15,010
这是一个非常奇怪的函数，类似于语法，

1617
01:11:15,010 --> 01:11:18,070
因为这里没有
涉及 return 语句。

1618
01:11:18,070 --> 01:11:22,310
这个机制，这个视图
构建器机制，知道如何

1619
01:11:22,310 --> 01:11:25,110
获取这个视图列表
并将它们实际组合

1620
01:11:25,110 --> 01:11:27,790
成另一个视图，它
是一个乐高视图包。

1621
01:11:27,790 --> 01:11:31,070
另一个 View 的类型
，你

1622
01:11:31,070 --> 01:11:34,870
不需要知道它是什么，
但它叫做 TupleView。

1623
01:11:34,870 --> 01:11:36,800
你永远不会

1624
01:11:36,800 --> 01:11:39,040
在代码中输入它，因为你不在乎。

1625
01:11:39,040 --> 01:11:40,470
这会自动发生在你身上，

1626
01:11:40,470 --> 01:11:43,557

这个创建乐高包的视图构建机制

1627
01:11:43,557 --> 01:11:45,660
，你会一直使用它。

1628
01:11:45,660 --> 01:11:48,660
您将一直列出
这样的视图。

1629
01:11:48,660 --> 01:11:51,100
这个乐高包

1630
01:11:51,100 --> 01:11:53,320
比仅仅列出 Views 还要强大。

1631
01:11:53,320 --> 01:11:56,510
你也可以把 if-then's 放在这里。

1632
01:11:56,510 --> 01:11:58,700
这些乐高包中可以

1633
01:11:58,700 --> 01:12:00,450
有条件语句。

1634
01:12:00,450 --> 01:12:03,740
你甚至可以在这里定义变量。

1635
01:12:03,740 --> 01:12:05,553

但你真的无能为力。

1636
01:12:05,553 --> 01:12:07,380
基本上，列出视图，

1637
01:12:07,380 --> 01:12:10,070
使用 if then's 来选择
你想

1638
01:12:10,070 --> 01:12:12,686
在乐高包中拥有哪些视图，然后

1639
01:12:12,686 --> 01:12:16,766
如果你需要做一些变量，
你也可以这样做。

1640
01:12:16,766 --> 01:12:19,410
请注意，我

1641
01:12:19,410 --> 01:12:20,680
在这里一直在后台安排这个。

1642
01:12:20,680 --> 01:12:24,010
我的文本也
有不同的行，

1643
01:12:24,010 --> 01:12:27,220
但我使用了缩进，
所以当我在这里查看这个

1644
01:12:27,220 --> 01:12:30,030
乐高包时，
我正在给 Zstack

1645
01:12:30,030 --> 01:12:34,510
，最左边的边缘
排列实际的视图

1646
01:12:34,510 --> 01:12:36,853
和 修饰符
缩进了一点。

1647
01:12:38,040 --> 01:12:40,740
这个 ZStack 的东西

1648
01:12:40,740 --> 01:12:43,420
对我们通过的这个乐高包有什么用？

1649
01:12:43,420 --> 01:12:47,730
好吧，ZStack 将这些
视图

1650
01:12:47,730 --> 01:12:50,550
从设备向外堆叠到用户的顶部。

1651
01:12:50,550 --> 01:12:52,130
正是我们想要的，对吧？

1652
01:12:52,130 --> 01:12:54,100
当我们构建这张卡片时，

1653
01:12:54,100 --> 01:12:56,990
有卡片的这种
背景

1654
01:12:56,990 --> 01:12:59,740
，然后在它上面有一条漂亮的

1655
01:13:00,780 --> 01:13:02,370
字符串，就是表情符号。

1656
01:13:02,370 --> 01:13:04,810
所以它把它们堆在我们面前。

1657
01:13:04,810 --> 01:13:08,220
还有其他组合器可以水平堆叠东西，也有其他组合器可以垂直堆叠，还有其他组合器
可以

1658
01:13:08,220 --> 01:13:10,460


1659
01:13:10,460 --> 01:13:13,810

像这样将它们堆叠成网格。

1660
01:13:13,810 --> 01:13:15,120
所以我们只是从第

1661
01:13:15,120 --> 01:13:16,970
一个构建卡片开始，但是当我们

1662
01:13:16,970 --> 01:13:18,740
想要拥有多张卡片时，
我们将开始使用

1663
01:13:18,740 --> 01:13:20,410
其他一些乐高组合器

1664
01:13:20,410 --> 01:13:22,060
以不同的方式组合它们。

1665
01:13:23,160 --> 01:13:25,960
你可以看到它实际上已经工作了，

1666
01:13:25,960 --> 01:13:29,283
背景卡然后
这里是我们的“Hello, world!”。

1667
01:13:30,230 --> 01:13:34,810
我们在这里构建的
实际上是一个 sum View

1668
01:13:34,810 --> 01:13:37,410
，它是一个

1669
01:13:37,410 --> 01:13:39,680
包含 RoundedRectangle 和 Text 的 ZStack。

1670
01:13:39,680 --> 01:13:43,850
这不仅仅是 ZStack，因为

1671
01:13:43,850 --> 01:13:46,720
ZStack 的类型包括其中包含

1672
01:13:46,720 --> 01:13:49,610
的事物的类型
。

1673
01:13:49,610 --> 01:13:52,680
所以说 ZStack 是行不通的。

1674
01:13:52,680 --> 01:13:53,863
我们让它建立。

1675
01:13:53,863 --> 01:13:56,060
你会看到这不会
允许这种情况发生。

1676
01:13:56,060 --> 01:13:58,870
这又是为什么我们需要一些视图。

1677
01:13:58,870 --> 01:14:03,120
我们构建了这个


1678
01:14:03,120 --> 01:14:05,140
与 ZStack 结合的复杂视图集合，

1679
01:14:05,140 --> 01:14:06,800
我们想让编译器找出

1680
01:14:06,800 --> 01:14:09,950
这里涉及的复杂类型。

1681
01:14:09,950 --> 01:14:12,360
所以我们从不使用一些 View 输入类型，

1682
01:14:12,360 --> 01:14:16,533
我们总是让一些
View 为我们计算。

1683
01:14:17,570 --> 01:14:19,300
我想谈谈

1684
01:14:19,300 --> 01:14:22,790
我们对这些修改器的一些修改。

1685
01:14:22,790 --> 01:14:25,740
现在，我们在这里有修饰符，

1686
01:14:25,740 --> 01:14:28,780
每个都是我们想要的，但是让我们来
谈谈

1687
01:14:28,780 --> 01:14:32,040
在
这些视图组合器中放置一个修饰符意味着什么。

1688
01:14:32,040 --> 01:14:33,950
这实际上是您想要放在 ZStack 上的两种
不同类别

1689
01:14:33,950 --> 01:14:37,290
的东西
。

1690
01:14:37,290 --> 01:14:39,400
其中之一可能是填充。

1691
01:14:39,400 --> 01:14:42,100
目前我们
在这个矩形上有填充，

1692
01:14:42,100 --> 01:14:43,700
我们也在文本上有填充。

1693
01:14:43,700 --> 01:14:45,500
您可以看到
文本周围有填充。

1694
01:14:45,500 --> 01:14:48,730
我们目前实际上
不需要在 Text 周围进行填充。

1695
01:14:48,730 --> 01:14:51,960
没有理由
在文本周围使用此填充。

1696
01:14:51,960 --> 01:14:53,700
因此，如果我们将其取下并重新开始，

1697
01:14:53,700 --> 01:14:56,293
它并不会真正
改变事情的运作方式。

1698
01:14:56,293 --> 01:14:58,930
我们在 RoundedRectangle 上也有填充
，

1699
01:14:58,930 --> 01:15:00,200
这是我们想要的，

1700
01:15:00,200 --> 01:15:01,808
因为我们不希望它

1701
01:15:01,808 --> 01:15:04,049
在此处的边缘附近。

1702
01:15:04,049 --> 01:15:08,310
但是我们可以把这个
填充放在 ZStack 本身上。

1703
01:15:08,310 --> 01:15:12,450
所以如果我把这个填充
从这里拿掉，然后把它放在这里，

1704
01:15:12,450 --> 01:15:15,090
我现在

1705
01:15:15,090 --> 01:15:17,630
就在我创建的这个 ZStack 上做这个填充功能。

1706
01:15:17,630 --> 01:15:21,900
记住 ZStack 只是一个
视图，它的行为就像一个视图，

1707
01:15:21,900 --> 01:15:24,270
因此它具有填充功能，

1708
01:15:24,270 --> 01:15:25,870
它也可以被填充

1709
01:15:25,870 --> 01:15:28,180
，看起来没有任何变化。

1710
01:15:28,180 --> 01:15:30,680
通过在此处放置填充，
一切看起来都一样，

1711
01:15:30,680 --> 01:15:32,180
但存在细微差别。

1712
01:15:32,180 --> 01:15:33,013
看这个。

1713
01:15:33,013 --> 01:15:34,960
如果我单击矩形，

1714
01:15:34,960 --> 01:15:38,150
您会看到
定义矩形所在位置的蓝线，

1715
01:15:38,150 --> 01:15:39,700
它不再被填充。

1716
01:15:39,700 --> 01:15:41,840
所以矩形上没有填充。

1717
01:15:41,840 --> 01:15:43,710
如果我单击 Zstack

1718
01:15:43,710 --> 01:15:45,950
，您可以在其中看到填充。

1719
01:15:45,950 --> 01:15:49,230
蓝线一直
延伸到那里的边缘。

1720
01:15:49,230 --> 01:15:53,700
像填充这样的视图修饰符


1721
01:15:53,700 --> 01:15:55,890
在 ZStack 这样的东西上工作得很好。

1722
01:15:55,890 --> 01:15:58,140

ZStack

1723
01:15:58,140 --> 01:16:00,300
和 RoundedRectangle 和 Text 之间没有真正的区别

1724
01:16:00,300 --> 01:16:02,370
，因为它们都只是视图，

1725
01:16:02,370 --> 01:16:05,310
所以它们当然都可以被填充。

1726
01:16:05,310 --> 01:16:08,385
但是当涉及到视图组合器时，还有其他类型的

1727
01:16:08,385 --> 01:16:09,960
修饰符有点
有趣

1728
01:16:09,960 --> 01:16:12,151
。
让我们以

1729
01:16:12,151 --> 01:16:13,730
前景颜色为例。

1730
01:16:13,730 --> 01:16:16,230
让

1731
01:16:16,230 --> 01:16:19,900
我们从这里的每个乐高积木

1732
01:16:19,900 --> 01:16:22,685
上去掉前景颜色，然后把它放在 ZStack 上。

1733
01:16:22,685 --> 01:16:24,580
看看那边发生了什么。

1734
01:16:24,580 --> 01:16:28,460
我把它放在这里，
ZStack 里面的所有东西都

1735
01:16:28,460 --> 01:16:29,610
变红了。

1736
01:16:29,610 --> 01:16:33,736
文本变为红色
，矩形变为红色。

1737
01:16:33,736 --> 01:16:35,610
那么说

1738
01:16:35,610 --> 01:16:39,930
组合器的前景色是红色是什么意思呢？

1739
01:16:39,930 --> 01:16:43,310
组合器本身实际上并没有
绘制任何东西。

1740
01:16:43,310 --> 01:16:46,720
它结合了其他
绘制的东西，即矩形

1741
01:16:46,720 --> 01:16:47,630
和文本。

1742
01:16:47,630 --> 01:16:52,420
所以这种修饰符会传递

1743
01:16:52,420 --> 01:16:54,150
给里面的所有东西。

1744
01:16:54,150 --> 01:16:56,890
把.foregroundColor(.red)
放在ZStack上，和

1745
01:16:56,890 --> 01:16:59,700
把它放在这里和单独放在这里是完全一样的

1746
01:16:59,700 --> 01:17:02,182
。

1747
01:17:02,182 --> 01:17:05,460
这只是默认颜色，

1748
01:17:05,460 --> 01:17:07,170
如果你把它放在 ZStack 上的话。

1749
01:17:07,170 --> 01:17:09,490
如果我仍然希望我的文本是橙色的，

1750
01:17:09,490 --> 01:17:13,910
我仍然可以说
.foregroundColor(.orange)

1751
01:17:13,910 --> 01:17:16,840
并且我的文本会变成橙色。

1752
01:17:16,840 --> 01:17:18,770
所以这是允许的。

1753
01:17:18,770 --> 01:17:20,780
这将是它的
前景色。

1754
01:17:20,780 --> 01:17:25,260
这是它
从其容器继承的默认值。

1755
01:17:25,260 --> 01:17:27,310
请记住，当我们构建这些复杂的视图时，我们最终
将

1756
01:17:27,310 --> 01:17:29,700
在容器中包含容器，在容器中

1757
01:17:29,700 --> 01:17:31,750


1758
01:17:31,750 --> 01:17:34,750
，令人敬畏的是
它们会将颜色

1759
01:17:34,750 --> 01:17:37,650
沿着链传递到每个级别。

1760
01:17:37,650 --> 01:17:41,960
因此，如果整个卡片网格都是红色的，

1761
01:17:41,960 --> 01:17:44,010
我们可能会在最顶层
将 foregroundColor 设置为红色

1762
01:17:44,010 --> 01:17:45,520
。

1763
01:17:45,520 --> 01:17:46,680
在网格中，我们将把它

1764
01:17:46,680 --> 01:17:48,850
设置为网格的前景颜色，

1765
01:17:48,850 --> 01:17:50,960
并且里面的所有东西，包括

1766
01:17:50,960 --> 01:17:54,000
所有这些卡片，都
将继承该颜色。

1767
01:17:54,000 --> 01:17:57,433
除非他们想覆盖
它，否则他们会得到那种颜色。

1768
01:17:59,150 --> 01:18:00,630
在我们继续之前，

1769
01:18:00,630 --> 01:18:03,670
我实际上想
稍微清理一下我的代码。

1770
01:18:03,670 --> 01:18:05,540
记得我们说过 Swift

1771
01:18:05,540 --> 01:18:08,560
不喜欢你
有很多无关紧要的东西。

1772
01:18:08,560 --> 01:18:11,680
例如，
foregroundColor(Color.orange)，

1773
01:18:11,680 --> 01:18:13,420
我们可以关闭这个颜色，

1774
01:18:13,420 --> 01:18:16,740
因为 Swift 可以
弄清楚那里发生了什么。

1775
01:18:16,740 --> 01:18:21,160
我们也知道这里的
返回，不需要。

1776
01:18:21,160 --> 01:18:25,380
这是一个函数，我们知道
它返回某种视图。

1777
01:18:25,380 --> 01:18:27,480
编译器可以在这里查看

1778
01:18:27,480 --> 01:18:30,460
并看到实际上只有
这一行代码。

1779
01:18:30,460 --> 01:18:32,180
这看起来像是多行代码，

1780
01:18:32,180 --> 01:18:33,660
但实际上是一回事。

1781
01:18:33,660 --> 01:18:35,380
这是一个修改后的 Zstack。

1782
01:18:35,380 --> 01:18:38,250
这是这个函数中唯一的东西
，

1783
01:18:38,250 --> 01:18:41,700
所以它知道要返回这个东西，

1784
01:18:41,700 --> 01:18:44,816
特别是因为它匹配
了那里的一些视图。

1785
01:18:44,816 --> 01:18:45,840
所以我们不需要那个。

1786
01:18:45,840 --> 01:18:48,990
但是这里还有一些
我们不需要的东西。

1787
01:18:48,990 --> 01:18:51,030
这个参数给Zstack，

1788
01:18:51,030 --> 01:18:52,480
ZStack只接受一个参数。

1789
01:18:52,480 --> 01:18:54,330
顺便说一句，它可能需要另一个论点。

1790
01:18:54,330 --> 01:18:56,800
让我们把它放在这里，对齐。

1791
01:18:56,800 --> 01:18:58,890
例如，顶部。

1792
01:18:58,890 --> 01:19:02,080
这仍然是把这两
件事叠加在一起

1793
01:19:02,080 --> 01:19:06,460
，“你好，世界！” 和
它周围的 RoundedRectangle，

1794
01:19:06,460 --> 01:19:09,610
但它正在对齐它们，所以
它们被卡在顶部

1795
01:19:09,610 --> 01:19:13,273
而不是默认
对齐方式，即中心。

1796
01:19:14,650 --> 01:19:17,440
让我们摆脱橙色文本，

1797
01:19:17,440 --> 01:19:18,803
我们希望它都是红色的。

1798
01:19:20,050 --> 01:19:24,673
这个参数在这里，
内容，它的值是一个函数，

1799
01:19:24,673 --> 01:19:26,900
这里是这些特殊的视图构建器函数之一，它把它

1800
01:19:26,900 --> 01:19:31,040

包装成一个乐高包，

1801
01:19:31,040 --> 01:19:32,597
但仍然是一个函数。

1802
01:19:32,597 --> 01:19:36,010
每当您

1803
01:19:36,010 --> 01:19:39,780
创建一个结构甚至调用一个函数

1804
01:19:39,780 --> 01:19:43,430
并且您传递一个其值为函数的参数时


1805
01:19:43,430 --> 01:19:46,710
，只要它
是最后一个参数之一，

1806
01:19:46,710 --> 01:19:51,710
就可以将其
从括号内删除

1807
01:19:53,560 --> 01:19:54,910
我们有这个 (alignment: .center

1808
01:19:54,910 --> 01:19:56,210
) 现在我有了这个功能，

1809
01:19:56,210 --> 01:19:57,860
就像挂在边缘一样。

1810
01:19:57,860 --> 01:19:59,810
它与这个功能非常相似，

1811
01:19:59,810 --> 01:20:03,880
挂在边缘和
这个身体的东西就在这里。

1812
01:20:03,880 --> 01:20:05,520
我们可以就这样离开。

1813
01:20:05,520 --> 01:20:07,430
我们为什么要这样做？

1814
01:20:07,430 --> 01:20:11,590
为什么 Swift 允许你
只使用最后一个参数？

1815
01:20:11,590 --> 01:20:14,130
如果它们都是函数，你也可以做
最后几个参数

1816
01:20:14,130 --> 01:20:15,510
。

1817
01:20:15,510 --> 01:20:17,080
为什么我们将它挂

1818
01:20:17,080 --> 01:20:19,790
在参数列表之外？

1819
01:20:19,790 --> 01:20:21,980
纯粹是为了好看。

1820
01:20:21,980 --> 01:20:25,330
这纯粹是因为它看起来
不错，

1821
01:20:25,330 --> 01:20:28,270
如果你没有另一个论点

1822
01:20:28,270 --> 01:20:30,150
或者你只是不
打算使用那个论点，它会更好。

1823
01:20:30,150 --> 01:20:33,380
在这种情况下，您也可以
去掉括号。

1824
01:20:33,380 --> 01:20:35,430
现在你有一个
漂亮的小代码

1825
01:20:35,430 --> 01:20:38,840
，上面写着，哦，我有一个
关于这两件事的 ZStack。

1826
01:20:38,840 --> 01:20:40,740
我们总是要这样做。

1827
01:20:40,740 --> 01:20:43,960
从来没有人打字，内容：这个东西。

1828
01:20:43,960 --> 01:20:46,500
他们都会把它关掉。

1829
01:20:46,500 --> 01:20:48,830
如果我们想把对齐
放在那里，那很好。

1830
01:20:48,830 --> 01:20:51,200
我们可以返回并进行对齐，

1831
01:20:51,200 --> 01:20:55,033
但如果我们不这样做，
我们总是这样做。

1832
01:20:56,230 --> 01:20:58,250
很多人直接进入

1833
01:20:58,250 --> 01:20:59,880
SwiftUI，他们从这个开始

1834
01:20:59,880 --> 01:21:02,150
，他们甚至不
明白这里发生了什么，

1835
01:21:02,150 --> 01:21:05,970
但这只是一个函数
，它是 ZStack 的参数，

1836
01:21:05,970 --> 01:21:08,540
是 ZStack 的内容参数

1837
01:21:08,540 --> 01:21:11,810
，它是一个特殊的函数
因为它是一个视图构建器

1838
01:21:11,810 --> 01:21:13,230
，您可以在其中列出视图

1839
01:21:13,230 --> 01:21:15,400
并为您打包它们。

1840
01:21:15,400 --> 01:21:17,300
但也仅此而已。

1841
01:21:18,410 --> 01:21:20,490
我们将坚持

1842
01:21:20,490 --> 01:21:22,590
大流行前的讲座时间表

1843
01:21:22,590 --> 01:21:25,830
，即有两个 80 分钟的讲座。

1844
01:21:25,830 --> 01:21:28,920
所以我将在这里停下来
，我们将在下

1845
01:21:28,920 --> 01:21:32,360
一次继续这个演示
并创建多张卡片

1846
01:21:32,360 --> 01:21:33,770
并让它们看起来更好一点，

1847
01:21:33,770 --> 01:21:35,580
让它们滚动一点，

1848
01:21:35,580 --> 01:21:37,443
添加一些按钮等开始。

1849
01:21:38,429 --> 01:21:41,993
- 更多， 请访问我们@stanford.edu。

